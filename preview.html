<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />

  <title>Socionics Typing v2.4</title>
  <meta name="theme-color" content="#ff4fd8" />

<style>
:root{
  --bg1:#fff7fb;
  --bg2:#f3f7ff;
  --panel:#ffffff;
  --ink:#0b1220;
  --muted:#51627d;
  --line:rgba(10,20,40,.12);

  --hi:#ff4fd8;
  --hi2:#39b8ff;

  --shadow:0 18px 60px rgba(16,24,40,.14);
  --shadow2:0 8px 24px rgba(16,24,40,.10);
  --glow:0 0 0 5px rgba(255,79,216,.16), 0 0 0 10px rgba(57,184,255,.10);
}
*{box-sizing:border-box}
html,body{
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Hiragino Sans","Noto Sans JP","Yu Gothic",Meiryo,sans-serif;
  background:
    radial-gradient(900px 600px at 10% 10%, rgba(255,79,216,.14), transparent 60%),
    radial-gradient(820px 560px at 90% 0%, rgba(57,184,255,.14), transparent 55%),
    radial-gradient(900px 650px at 50% 105%, rgba(34,197,94,.10), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg2));
  color:var(--ink);
  letter-spacing:.01em;
}
.wrap{max-width:1180px;margin:0 auto;padding:14px;display:grid;gap:12px}

.topbar{
  display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
  padding:14px 16px;border:1px solid var(--line);border-radius:18px;
  background:rgba(255,255,255,.85);backdrop-filter: blur(10px);
  box-shadow:var(--shadow);
}
.brand{display:flex;align-items:center;gap:10px}
.logo{
  width:36px;height:36px;border-radius:14px;
  background:linear-gradient(135deg,var(--hi),var(--hi2));
  box-shadow:0 14px 30px rgba(255,79,216,.18);
}
.brand h1{margin:0;font-size:14px;font-weight:1000;letter-spacing:.08em}
.actions{display:flex;gap:8px;flex-wrap:wrap}

.btn{
  padding:10px 12px;border:1px solid var(--line);border-radius:14px;
  background:rgba(255,255,255,.9);color:var(--ink);
  font-weight:1000;cursor:pointer;min-height:42px;user-select:none;
  box-shadow:var(--shadow2);
}
.btn.primary{
  border-color:transparent;
  background:linear-gradient(135deg,var(--hi),var(--hi2));
  color:#fff;
  box-shadow:0 14px 30px rgba(57,184,255,.18);
}
.btn:active{transform:scale(.99)}
.btn[disabled]{opacity:.45;cursor:not-allowed}

.grid{display:grid;gap:12px}
@media(min-width:940px){
  .grid{grid-template-columns: 1.25fr .75fr;}
}

.card{
  border:1px solid var(--line);
  border-radius:18px;
  background:rgba(255,255,255,.85);
  backdrop-filter: blur(10px);
  box-shadow:var(--shadow);
  overflow:hidden;
}
.body{padding:16px;display:grid;gap:12px}

.row{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.bar{
  flex:1;min-width:220px;height:12px;border-radius:999px;overflow:hidden;
  border:1px solid var(--line);background:rgba(10,20,40,.06)
}
.bar>div{height:100%;width:0%;background:linear-gradient(90deg,var(--hi),var(--hi2))}
.badge{
  display:inline-flex;align-items:center;gap:8px;
  padding:8px 12px;border-radius:999px;border:1px solid var(--line);
  background:rgba(255,255,255,.9);font-size:12px;color:var(--ink);font-weight:1000;
  box-shadow:var(--shadow2);
}

.qbox{
  border:1px solid var(--line);
  border-radius:16px;
  padding:16px;
  background:rgba(255,255,255,.9);
  box-shadow:var(--shadow2);
}
.qno{font-weight:1200;font-size:12px;color:var(--muted);letter-spacing:.12em}
.qtext{font-size:16px;line-height:1.85;margin:10px 0 14px}

.scale5,.scale3{display:grid;gap:10px}
@media(min-width:740px){ .scale5{grid-template-columns:repeat(5,1fr)} .scale3{grid-template-columns:repeat(3,1fr)} }

.opt{
  border:1px solid var(--line); border-radius:16px; padding:12px;
  background:rgba(255,255,255,.95); cursor:pointer; user-select:none;
  display:flex; align-items:center; gap:10px; min-height:56px;
  transition:.12s;
  box-shadow:0 10px 18px rgba(16,24,40,.06);
}
.opt:hover{transform:translateY(-1px);box-shadow:var(--glow)}
.dot{
  width:16px;height:16px;border-radius:999px;border:2px solid rgba(10,20,40,.25);
  display:inline-block;position:relative;flex:0 0 auto
}
.opt.sel{
  border-color:rgba(255,79,216,.55);
  box-shadow:var(--glow);
}
.opt.sel .dot{border-color:var(--hi)}
.opt.sel .dot::after{
  content:"";position:absolute;inset:3px;border-radius:999px;background:var(--hi)
}
.lab{font-size:13px;color:var(--ink);font-weight:1100}
.subv{font-size:11px;color:var(--muted);margin-left:auto;font-weight:1100}

.controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}

.kv{
  border:1px solid var(--line);
  border-radius:16px;
  background:rgba(255,255,255,.9);
  padding:12px;
  box-shadow:var(--shadow2);
}
.kv .t{font-size:12px;color:var(--muted);letter-spacing:.10em}

.rankItem{
  display:flex;align-items:center;justify-content:space-between;gap:10px;
  padding:10px 12px;border-radius:16px;border:1px solid var(--line);
  background:rgba(255,255,255,.95);
  box-shadow:0 10px 18px rgba(16,24,40,.06);
}
.rankItem b{font-weight:1200}
.pct{font-weight:1200}
.hr{height:1px;background:var(--line);margin:8px 0}
.small{font-size:12px;color:var(--muted);line-height:1.7}
.hidden{display:none !important;}
.pill{
  display:inline-flex;align-items:center;gap:8px;
  border:1px solid var(--line);
  background:rgba(10,20,40,.04);
  padding:6px 10px;border-radius:999px;
  font-size:12px;color:var(--ink);font-weight:1100;
}

/* Visualization grid for results */
.vizGrid{display:grid;gap:8px}
.vizRow{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
.vizRow b{min-width:200px;display:inline-block;font-weight:800}
.vizBar{flex:1;height:10px;border-radius:999px;background:rgba(10,20,40,.06);overflow:hidden;border:1px solid var(--line)}
.vizBar i{display:block;height:100%;background:linear-gradient(90deg,var(--hi),var(--hi2));width:0}
.vizPct{width:56px;text-align:right;font-weight:800;color:var(--muted)}

/* Split bar for signed element scores */
.vizBarSplit{
  flex:1;height:14px;border-radius:8px;background:rgba(10,20,40,.06);overflow:hidden;border:1px solid var(--line);display:flex;align-items:center;
  position:relative;
}
.vizBarSplit .neg{height:8px;background:linear-gradient(90deg,#f0c6ff,#ffd6f8);border-radius:6px 0 0 6px;}
.vizBarSplit .pos{height:8px;background:linear-gradient(90deg,#bfe9ff,#39b8ff);border-radius:0 6px 6px 0;}
.vizBarSplit .centerLine{position:absolute;left:50%;top:0;bottom:0;width:1px;background:var(--line);transform:translateX(-0.5px)}
.vizBarSplit .barWrap{display:flex;width:100%;justify-content:center;align-items:center;padding:3px}

/* small adjustments for result cards */
.qbox .small b{font-weight:900}

/* hide any catMapping completely */
#catMapping{display:none !important;}

/* small unobtrusive export link/button */
.exportLink{
  background:transparent;border:0;color:var(--muted);font-size:12px;padding:4px 6px;cursor:pointer;text-decoration:underline;
  border-radius:6px;
}
</style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>Socionics Typing v2.4 </h1>
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="btnToggleLive">上位候補を表示</button>
      <button class="btn" id="btnRestartTop">最初から</button>
    </div>
  </div>

  <div class="grid">
    <!-- MAIN -->
    <div class="card">
      <div class="body" id="screenQuiz">
        <div class="row">
          <div class="bar" aria-label="progress"><div id="barFill"></div></div>
          <div class="badge"><b id="progText">0 / 60</b></div>
        </div>

        <div id="bootError" class="err hidden"></div>

        <div class="qbox">
          <div class="qno" id="qNo">Q1</div>
          <div class="qtext" id="qText">—</div>

          <div id="catMapping" class="small" style="opacity:.9"></div>

          <div class="scale5" id="scale5"></div>
          <div class="scale3" id="scale3" style="display:none"></div>

          <div class="controls" style="margin-top:12px">
            <button class="btn" id="btnBack" disabled>戻る</button>
            <button class="btn" id="btnSkip">わからない</button>
            <button class="btn primary" id="btnNext" disabled>次へ</button>
          </div>
        </div>
      </div>

      <div class="body" id="screenResult" style="display:none">
        <div class="qbox">
          <div class="small">結果（上位3タイプ）</div>
          <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
            <div style="font-size:18px;font-weight:1200;margin-top:6px" id="resHeadline">—</div>
            <!-- unobtrusive export link -->
            <div style="text-align:right">
              <button id="btnExportData" class="exportLink" title="診断データをJSONとして保存（任意）">診断データを保存（任意）</button>
            </div>
          </div>
          <div class="hr"></div>
          <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end">
            <button class="btn primary" id="btnRestart">最初から</button>
          </div>
        </div>

        <!-- 簡易ビジュアル（情報要素の価値寄り度・クアドラ割合） -->
        <div class="qbox">
          <div class="row">
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
              <span class="pill">詳細グラフ</span>
              <span class="small">（回答傾向を視覚化します）</span>
            </div>
          </div>
          <div class="hr"></div>
          <div style="display:grid;gap:14px">
            <div>
              <div style="font-weight:1200;margin-bottom:8px">情報要素（価値寄り度）</div>
              <div id="elementViz" class="vizGrid"></div>
            </div>
            <div>
              <div style="font-weight:1200;margin-bottom:8px">クアドラ割合（推定）</div>
              <div id="quadraViz" class="vizGrid"></div>
            </div>
          </div>
        </div>

        <div id="resCards" style="display:grid;gap:12px;margin-top:12px"></div>

        <!-- Feedback -->
        <div class="qbox" id="feedbackBox">
          <div class="row">
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
              <span class="pill">フィードバック</span>
              <span class="small">（1位タイプを前提に、回答傾向を要点化します）</span>
            </div>
            <button class="btn" id="btnToggleFeedback">開く</button>
          </div>
          <div class="hr"></div>
          <div id="feedbackContent" class="hidden">
            <div class="small" id="fbQuadra">—</div>
            <div style="display:grid;gap:10px;margin-top:10px">
              <div>
                <div style="font-weight:1200;margin-bottom:6px">価値（優先しやすい情報要素）</div>
                <div class="small" id="fbValues">—</div>
              </div>
              <div>
                <div style="font-weight:1200;margin-bottom:6px">回答から見えた強まり</div>
                <div class="small" id="fbStrong">—</div>
              </div>
              <div>
                <div style="font-weight:1200;margin-bottom:6px">1位タイプらしさとズレやすい点（要注意ポイント）</div>
                <div class="small" id="fbMismatch">—</div>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <!-- SIDE -->
    <div class="card hidden" id="sideCard">
      <div class="body">
        <div class="kv">
          <div class="t">上位候補</div>
          <div id="topList" style="display:grid;gap:10px;margin-top:10px"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  /* --------------------------
     Core constants / models
     -------------------------- */
  const TYPES=["ILE","SEI","ESE","LII","EIE","LSI","SLE","IEI","SEE","ILI","LIE","ESI","LSE","EII","IEE","SLI"];
  const ELEMENTS=["Te","Ti","Fe","Fi","Ne","Ni","Se","Si"];

  const QUADRA={
    ILE:"Alpha", SEI:"Alpha", ESE:"Alpha", LII:"Alpha",
    EIE:"Beta",  LSI:"Beta",  SLE:"Beta",  IEI:"Beta",
    SEE:"Gamma", ILI:"Gamma", LIE:"Gamma", ESI:"Gamma",
    IEE:"Delta", SLI:"Delta", LSE:"Delta", EII:"Delta"
  };
  const QSYM={Alpha:"α",Beta:"β",Gamma:"γ",Delta:"Δ"};

  const MODEL={
    ILE:["Ne","Ti","Se","Fi","Si","Fe","Ni","Te"],
    SEI:["Si","Fe","Ni","Te","Ne","Ti","Se","Fi"],
    ESE:["Fe","Si","Te","Ni","Ti","Ne","Fi","Se"],
    LII:["Ti","Ne","Fi","Se","Fe","Si","Te","Ni"],
    EIE:["Fe","Ni","Te","Si","Ti","Se","Fi","Ne"],
    SLE:["Se","Ti","Ne","Fi","Ni","Fe","Si","Te"],
    LSI:["Ti","Se","Fi","Ne","Fe","Ni","Te","Si"],
    IEI:["Ni","Fe","Si","Te","Se","Ti","Ne","Fi"],
    SEE:["Se","Fi","Ne","Ti","Ni","Te","Si","Fe"],
    ILI:["Ni","Te","Si","Fe","Se","Fi","Ne","Ti"],
    LIE:["Te","Ni","Fe","Si","Fi","Se","Ti","Ne"],
    ESI:["Fi","Se","Ti","Ne","Te","Ni","Fe","Si"],
    SLI:["Si","Te","Ni","Fe","Ne","Fi","Se","Ti"],
    IEE:["Ne","Fi","Se","Ti","Si","Te","Ni","Fe"],
    LSE:["Te","Si","Fe","Ni","Fi","Ne","Ti","Se"],
    EII:["Fi","Ne","Ti","Se","Te","Si","Fe","Ni"]
  };

  const QUADRA_VALUES={
    Alpha:new Set(["Ne","Ti","Fe","Si"]),
    Beta :new Set(["Fe","Ni","Se","Ti"]),
    Gamma:new Set(["Fi","Te","Se","Ni"]),
    Delta:new Set(["Si","Te","Fi","Ne"])
  };

  const DICH = {
    E: new Set(["ILE","ESE","EIE","SLE","SEE","LIE","LSE","IEE"]),
    I: new Set(["LII","SEI","LSI","IEI","ESI","ILI","SLI","EII"]),
    S: new Set(["SEI","ESE","LSI","SLE","SEE","ESI","LSE","SLI"]),
    N: new Set(["ILE","LII","EIE","IEI","IEE","EII","LIE","ILI"]),
    T: new Set(["ILE","LII","LSI","SLE","LIE","LSE","ILI","SLI"]),
    F: new Set(["SEI","ESE","EIE","IEI","SEE","ESI","IEE","EII"]),
    J: new Set(["LII","ESE","EIE","LSI","ESI","LIE","LSE","EII"]),
    P: new Set(["ILE","SEI","SLE","IEI","SEE","ILI","SLI","IEE"])
  };

  /* --------------------------
     Utility math
     -------------------------- */
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const sigmoid=(x)=>1/(1+Math.exp(-x));
  function normalizeVec(obj){
    const s = Object.values(obj).reduce((a,b)=>a+b,0) || 1;
    const out={}; for(const k in obj) out[k]=obj[k]/s; return out;
  }
  function entropy(probs){
    let h=0;
    for(const p of Object.values(probs||{})){
      if(p<=0) continue;
      h -= p*Math.log(p);
    }
    return h;
  }
  const topN=(probs,n=3)=>Object.entries(probs).sort((a,b)=>b[1]-a[1]).slice(0,n);

  /* --------------------------
     QUESTIONS: id:1 replaced; id:45 removed
     NOTE: QUESTIONS.length now drives progress display and iteration.
     -------------------------- */
  const QUESTIONS = [
  {"id":1,"phase":1,"text":"集まりや飲み会の翌日は、一人で静かに回復する時間が必要になりやすい。","axis":"EI","axisDir":"I","element":null,"dimension":"none","weight":1.8},
  {"id":2,"phase":1,"text":"仕事や課題で詰まったとき、誰かに話しながら整理する方です。","axis":"EI","axisDir":"E","element":null,"dimension":"none","weight":1.8},
  {"id":3,"phase":1,"text":"初対面の人が多い場では、自分から話しかける方です。","axis":"EI","axisDir":"E","element":null,"dimension":"none","weight":1.8},
  {"id":4,"phase":1,"text":"忙しい日は、相談や打ち合わせを入れて進めたい方です。","axis":"EI","axisDir":"E","element":null,"dimension":"none","weight":1.8},
  {"id":5,"phase":1,"text":"数か月続くチーム作業で、人と関わり続けるのはあまり負担になりません。","axis":"EI","axisDir":"E","element":null,"dimension":"none","weight":1.8},

  {"id":6,"phase":1,"text":"説明するときは、実際にあった話や具体例から話すことが多いです。","axis":"SN","axisDir":"S","element":null,"dimension":"none","weight":1.8},
  {"id":7,"phase":1,"text":"旅行や企画を考えるとき、体験の雰囲気より「何をするか」を先に決めます。","axis":"SN","axisDir":"S","element":null,"dimension":"none","weight":1.8},
  {"id":8,"phase":1,"text":"人の話を聞くとき、「それが何を示すか」より「何が起きたか」が印象に残ります。","axis":"SN","axisDir":"S","element":null,"dimension":"none","weight":1.8},
  {"id":9,"phase":1,"text":"仕事の指示は、狙いより手順を細かく伝える方です。","axis":"SN","axisDir":"S","element":null,"dimension":"none","weight":1.8},
  {"id":10,"phase":1,"text":"アイデアは、面白さよりも「実際に使えるか」で評価しがちです。","axis":"SN","axisDir":"S","element":null,"dimension":"none","weight":1.8},

  {"id":11,"phase":1,"text":"意見が割れたら、納得感より数字や根拠で決めたいです。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.8},
  {"id":12,"phase":1,"text":"人を評価するとき、人柄より成果・スキルを重視します。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.8},
  {"id":13,"phase":1,"text":"注意するとき、言い方より正しさを優先します。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.8},
  {"id":14,"phase":1,"text":"議論中は、その場の雰囲気より話が論理的かが気になります。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.8},
  {"id":15,"phase":1,"text":"チームでは、関係性より役割と成果を重視します。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.8},

  {"id":16,"phase":1,"text":"締切前に迷ったとき、多少荒くても出す方です。","axis":"JP","axisDir":"P","element":null,"dimension":"none","weight":1.8},
  {"id":17,"phase":1,"text":"トラブル時は、気持ちより原因と手順の整理を優先します。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.8},
  {"id":18,"phase":1,"text":"新しい企画は、面白そうかより実現できるかを先に見ます。","axis":"SN","axisDir":"S","element":null,"dimension":"none","weight":1.8},
  {"id":19,"phase":1,"text":"一緒に働く人に求めるのは、性格の良さより仕事ができることです。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.8},
  {"id":20,"phase":1,"text":"会話では、気持ちの伝わりやすさより内容の正確さを重視します。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.8},

  {"id":21,"phase":2,"text":"話し合いで案が1つに絞られていくと、「他の案も考えたい」と物足りなく感じます。","axis":null,"axisDir":null,"element":"Ne","dimension":"none","weight":1.0},
  {"id":22,"phase":2,"text":"新しい話を聞くと、「もっと別の形もありそう」と自然に考えます。","axis":null,"axisDir":null,"element":"Ne","dimension":"none","weight":1.0},
  {"id":23,"phase":2,"text":"選択肢が少ない状況は、少し窮屈に感じます。","axis":null,"axisDir":null,"element":"Ne","dimension":"none","weight":1.0},

  {"id":24,"phase":2,"text":"出来事を見るとき、「この先どうなりそうか」を考えるのが自然です。","axis":null,"axisDir":null,"element":"Ni","dimension":"none","weight":1.0},
  {"id":25,"phase":2,"text":"決断するとき、「今かどうか」というタイミングを重視します。","axis":null,"axisDir":null,"element":"Ni","dimension":"none","weight":1.0},
  {"id":26,"phase":2,"text":"短期の成果より、長期の方向性の方が気になります。","axis":null,"axisDir":null,"element":"Ni","dimension":"none","weight":1.0},

  {"id":27,"phase":2,"text":"迷っている場面では、誰かが決めて前に進めると安心します。","axis":null,"axisDir":null,"element":"Se","dimension":"none","weight":1.0},
  {"id":28,"phase":2,"text":"必要なら、少し強く言ってでも進めたいと思います。","axis":null,"axisDir":null,"element":"Se","dimension":"none","weight":1.0},
  {"id":29,"phase":2,"text":"グループワークにおいて、主導権を握って動かす方が落ち着きます。","axis":null,"axisDir":null,"element":"Se","dimension":"none","weight":1.0},

  {"id":30,"phase":2,"text":"環境や体調が整っていると、気持ちも安定します。","axis":null,"axisDir":null,"element":"Si","dimension":"none","weight":1.0},
  {"id":31,"phase":2,"text":"無理のないペースで進められると安心します。","axis":null,"axisDir":null,"element":"Si","dimension":"none","weight":1.0},
  {"id":32,"phase":2,"text":"小さな不快が続くと、集中しにくくなります。","axis":null,"axisDir":null,"element":"Si","dimension":"none","weight":1.0},

  {"id":33,"phase":2,"text":"言葉やルールの意味が曖昧だと、まずはっきりさせたくなります。","axis":null,"axisDir":null,"element":"Ti","dimension":"none","weight":1.0},
  {"id":34,"phase":2,"text":"話を聞くとき、筋が通っているかが気になります。","axis":null,"axisDir":null,"element":"Ti","dimension":"none","weight":1.0},
  {"id":35,"phase":2,"text":"分類や整理ができると、頭がすっきりします。","axis":null,"axisDir":null,"element":"Ti","dimension":"none","weight":1.0},

  {"id":36,"phase":2,"text":"話が長くなると、「結局どうすればいいのか」を知りたくなります。","axis":null,"axisDir":null,"element":"Te","dimension":"none","weight":1.0},
  {"id":37,"phase":2,"text":"実績や数字があると、安心して判断できます。","axis":null,"axisDir":null,"element":"Te","dimension":"none","weight":1.0},
  {"id":38,"phase":2,"text":"成果につながらない作業は、早めに切り替えたいです。","axis":null,"axisDir":null,"element":"Te","dimension":"none","weight":1.0},

  {"id":39,"phase":2,"text":"場が静かすぎると、自分から少し動かしたくなります。","axis":null,"axisDir":null,"element":"Fe","dimension":"none","weight":1.0},
  {"id":40,"phase":2,"text":"感情を言葉にして共有できると、やりやすくなります。","axis":null,"axisDir":null,"element":"Fe","dimension":"none","weight":1.0},
  {"id":41,"phase":2,"text":"雰囲気が重いと、変えたくなります。","axis":null,"axisDir":null,"element":"Fe","dimension":"none","weight":1.0},

  {"id":42,"phase":2,"text":"人を見るとき、能力より誠実さが気になります。","axis":null,"axisDir":null,"element":"Fi","dimension":"none","weight":1.0},
  {"id":43,"phase":2,"text":"一対一において距離感が合わないと、居心地が悪くなります。","axis":null,"axisDir":null,"element":"Fi","dimension":"none","weight":1.0},
  {"id":44,"phase":2,"text":"友人に求める一番の条件は、約束や道理を守る人です。","axis":null,"axisDir":null,"element":"Fi","dimension":"none","weight":1.0},
  {"id":45,"phase":2,"text":"好意や信頼を向ける相手は、かなりはっきりと選んでいます。","axis":null,"axisDir":null,"element":"Fi","dimension":"none","weight":1.0},

  {"id":46,"phase":3,"text":"話がごちゃごちゃしている場面で、考える前に「話を整理し直している」ことがあります。","axis":"TF","axisDir":"T","element":"Ti","dimension":"unconscious","weight":0.7},
  {"id":47,"phase":3,"text":"場の雰囲気が重いとき、自然と「空気を和らげる行動」をしています。","axis":"TF","axisDir":"F","element":"Fe","dimension":"unconscious","weight":0.7},
  {"id":48,"phase":3,"text":"迷っている人を見ると、つい「決断を後押しする言葉や行動」を取ってしまいます。","axis":"EI","axisDir":"E","element":"Se","dimension":"unconscious","weight":0.7},
  {"id":49,"phase":3,"text":"初めての作業や役割でも、「どう動けばいいか」はあまり迷いません。","axis":"EI","axisDir":"E","element":"Te","dimension":"unconscious","weight":0.7},
  {"id":50,"phase":3,"text":"人の話を聞くとき、内容よりも「流れ」や「タイミング」が先に気になります。","axis":"SN","axisDir":"N","element":"Ni","dimension":"unconscious","weight":0.7},

  {"id":51,"phase":3,"text":"体調や気分が良くない日でも、「いつも通りできる作業や判断」は大きく崩れません。","axis":"SN","axisDir":"S","element":"Si","dimension":"stable","weight":0.7},
  {"id":52,"phase":3,"text":"職場や環境が変わっても、自分のやり方や考え方はあまり変わりません。","axis":"SN","axisDir":"S","element":"Te","dimension":"stable","weight":0.7},
  {"id":53,"phase":3,"text":"失敗したあとも、ガラッと手順を変えずだいたい同じやり方で対応します。","axis":"SN","axisDir":"S","element":"Te","dimension":"stable","weight":0.7},
  {"id":54,"phase":3,"text":"忙しいときほど、自然と「自分の決まった動き方」で行動しています。","axis":"EI","axisDir":"E","element":"Se","dimension":"stable","weight":0.7},
  {"id":55,"phase":3,"text":"状況が変わっても、同じ基準や考え方で判断しています。","axis":"TF","axisDir":"T","element":"Ti","dimension":"stable","weight":0.7},

  {"id":56,"phase":3,"text":"仕事や作業の進め方について、「どういう手順でやっているか」を人に説明できます。","axis":"SN","axisDir":"S","element":"Te","dimension":"reproducible","weight":0.7},
  {"id":57,"phase":3,"text":"話し合いで意見を出すとき、「なぜそう考えたか」を言葉で説明できます。","axis":"TF","axisDir":"T","element":"Ti","dimension":"reproducible","weight":0.7},
  {"id":58,"phase":3,"text":"周りから、「それどうやってやってるの？」とやり方について教えを求められることがあります。","axis":"SN","axisDir":"S","element":"Te","dimension":"reproducible","weight":0.7},
  {"id":59,"phase":3,"text":"自分の中で、「物事の考え方」「作業の進め方」の型がはっきりしています。","axis":"TF","axisDir":"T","element":"Ti","dimension":"reproducible","weight":0.7},
  {"id":60,"phase":3,"text":"誰かに教えるとき、手順や考え方を順番に説明しています。","axis":"TF","axisDir":"F","element":"Fe","dimension":"reproducible","weight":0.7}
  ];

  /* --------------------------
     SCALE mapping (5-point)
     -------------------------- */
  const SCALE5=[
    {label:"そう思う", v:+2, c:0},
    {label:"部分的にそう思う", v:+1, c:1},
    {label:"中立", v:0, c:2},
    {label:"あまりそう思わない", v:-1, c:3},
    {label:"全くそう思わない", v:-2, c:4},
  ];

  /* --------------------------
     State
     -------------------------- */
  const state = {
    step: 0,
    asked: QUESTIONS.map((q,i)=>i),
    answers: [],
    posterior: Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length])),
    quadra: {Alpha:0.25,Beta:0.25,Gamma:0.25,Delta:0.25},
    axisScores: {E:0,I:0,S:0,N:0,T:0,F:0,J:0,P:0},
    elementScores: Object.fromEntries(ELEMENTS.map(e=>[e,0])),
    dimensionScores: {},
    respStats:{n:0, mean:0, m2:0, neutral:0, extreme:0},
    historyTop1:[],
    historyTop1Pct:[],
    historyGap:[],
    history: [],
    isAdvancing:false,
    livePinned:false
  };

  /* --------------------------
     UI elems
     -------------------------- */
  const elBarFill=document.getElementById("barFill");
  const elProg=document.getElementById("progText");
  const elQNo=document.getElementById("qNo");
  const elQText=document.getElementById("qText");
  const elScale5=document.getElementById("scale5");
  const elScale3=document.getElementById("scale3");
  const btnBack=document.getElementById("btnBack");
  const btnSkip=document.getElementById("btnSkip");
  const btnNext=document.getElementById("btnNext");
  const screenQuiz=document.getElementById("screenQuiz");
  const screenResult=document.getElementById("screenResult");
  const topList=document.getElementById("topList");
  const sideCard=document.getElementById("sideCard");
  const btnToggleLive=document.getElementById("btnToggleLive");

  function setProgress(){ elProg.textContent = `${state.step} / ${QUESTIONS.length}`; elBarFill.style.width = `${clamp(state.step/QUESTIONS.length,0,1)*100}%`; }

  /* --------------------------
     Existing helpers reused: stabilizePosterior, etc.
     (kept from prior implementation)
     -------------------------- */
  function sumSet(posterior, set){
    let s=0; for(const t of set) s += (posterior[t]||0);
    return s;
  }
  function factorizedFromDich(p){
    const pE = sumSet(p, DICH.E);
    const pS = sumSet(p, DICH.S);
    const pT = sumSet(p, DICH.T);
    const pJ = sumSet(p, DICH.J);
    const w = {};
    for(const t of TYPES){
      const e = DICH.E.has(t) ? pE : (1-pE);
      const s = DICH.S.has(t) ? pS : (1-pS);
      const tt= DICH.T.has(t) ? pT : (1-pT);
      const j = DICH.J.has(t) ? pJ : (1-pJ);
      w[t] = Math.max(1e-12, e*s*tt*j);
    }
    return normalizeVec(w);
  }
  function applyAxisSoftElimination(p, step){
    if(step < 8) return p;
    const pE = sumSet(p, DICH.E);
    const pS = sumSet(p, DICH.S);
    const pT = sumSet(p, DICH.T);
    const confE = Math.abs(pE - 0.5) * 2;
    const confS = Math.abs(pS - 0.5) * 2;
    const confT = Math.abs(pT - 0.5) * 2;
    const phase = step < 18 ? 0.55 : step < 30 ? 0.75 : 1.0;
    const confStart = 0.55;
    const strengthMax = 0.55;
    function axisPenalty(conf){
      if(conf <= confStart) return 1.0;
      const x = (conf - confStart) / (1 - confStart);
      const strength = Math.max(0, Math.min(1, x)) * strengthMax * phase;
      return Math.exp(-strength);
    }
    const penE = axisPenalty(confE);
    const penS = axisPenalty(confS);
    const penT = axisPenalty(confT);
    const out = {...p};
    for(const t of TYPES){
      let m = 1.0;
      if(pE >= 0.5 && DICH.I.has(t)) m *= penE;
      if(pE <  0.5 && DICH.E.has(t)) m *= penE;
      if(pS >= 0.5 && DICH.N.has(t)) m *= penS;
      if(pS <  0.5 && DICH.S.has(t)) m *= penS;
      if(pT >= 0.5 && DICH.F.has(t)) m *= penT;
      if(pT <  0.5 && DICH.T.has(t)) m *= penT;
      out[t] = (out[t]||0) * m;
    }
    return normalizeVec(out);
  }
  function getStabilizeLam(step){ return step < 20 ? 0.30 : step < 40 ? 0.20 : 0.22; }
  function stabilizePosterior(posterior, step){
    const lam = getStabilizeLam(step);
    const w = factorizedFromDich(posterior);
    const mixed = {};
    for(const t of TYPES) mixed[t] = (1-lam)*(posterior[t]||0) + lam*(w[t]||0);
    const normed = normalizeVec(mixed);
    const suppressed = applyAxisSoftElimination(normed, step);
    return normalizeVec(suppressed);
  }

  /* --------------------------
     computeQuadraFromPosterior + sharpening utilities
     -------------------------- */
  function computeQuadraFromPosterior(posterior){
    const quadra = {Alpha:0,Beta:0,Gamma:0,Delta:0};
    for(const t of TYPES){
      const q = QUADRA[t];
      quadra[q] += (posterior[t] || 0);
    }
    const s = quadra.Alpha + quadra.Beta + quadra.Gamma + quadra.Delta || 1;
    quadra.Alpha /= s; quadra.Beta /= s; quadra.Gamma /= s; quadra.Delta /= s;
    return quadra;
  }
  function sharpenDistribution(dist, k){
    const powered = {};
    for(const key of Object.keys(dist)){
      powered[key] = Math.pow(Math.max(1e-12, dist[key]||0), k);
    }
    return normalizeVec(powered);
  }
  function sharpenPosterior(posterior, k){
    const out = {};
    for(const t of TYPES) out[t] = Math.pow(Math.max(1e-12, posterior[t]||0), k);
    return normalizeVec(out);
  }
  function getSharpenK(step){
    const base = 1.0 + 1.5 * (step / (QUESTIONS.length - 1));
    return clamp(base, 1.0, 2.5);
  }
  function top1Prob(posterior){
    let best = 0;
    for(const v of Object.values(posterior)) if(v > best) best = v;
    return best || 0;
  }

  /* --------------------------
     Scoring and posterior recomputation (kept intact)
     -------------------------- */
  function updateRespStatsLikert(raw){
    const s=state.respStats;
    s.n+=1;
    const delta=raw-s.mean;
    s.mean+=delta/s.n;
    const delta2=raw-s.mean;
    s.m2+=delta*delta2;
    if(raw===0) s.neutral+=1;
    if(Math.abs(raw)===2) s.extreme+=1;
  }
  function stdev(){ const s=state.respStats; if(s.n<8) return 1.0; const v=s.m2/(s.n-1); return clamp(Math.sqrt(v), 0.55, 1.55); }
  function temperature(){ const s=state.respStats; const sd=stdev(); const neutralRate = s.n>0 ? (s.neutral/s.n) : 0; const extremeRate = s.n>0 ? (s.extreme/s.n) : 0; let T=1.0; if(neutralRate>0.48) T+=0.18; if(extremeRate>0.62) T+=0.12; if(sd<0.78) T+=0.12; if(sd>1.22) T+=0.12; return clamp(T, 0.85, 1.65); }
  const tempAdjustLike=(like)=>Math.pow(Math.max(1e-12, like), 1.0/temperature());

  function recomputePosteriorFromScores(stepForStabilize){
    const valE = (state.axisScores.E || 0) - (state.axisScores.I || 0);
    const valS = (state.axisScores.S || 0) - (state.axisScores.N || 0);
    const valT = (state.axisScores.T || 0) - (state.axisScores.F || 0);
    const valJ = (state.axisScores.J || 0) - (state.axisScores.P || 0);

    const pE = sigmoid(valE * 0.4);
    const pS = sigmoid(valS * 0.4);
    const pT = sigmoid(valT * 0.4);
    const pJ = sigmoid(valJ * 0.35);

    let maxAbsElem = 0;
    for(const e of ELEMENTS) maxAbsElem = Math.max(maxAbsElem, Math.abs(state.elementScores[e]||0));
    const elemScale = maxAbsElem > 0 ? (1 / maxAbsElem) : 1;

    const rawScores = {};
    for(const t of TYPES){
      let axisMatch = 0;
      axisMatch += (DICH.E.has(t) ? pE : (1-pE));
      axisMatch += (DICH.S.has(t) ? pS : (1-pS));
      axisMatch += (DICH.T.has(t) ? pT : (1-pT));
      axisMatch += (DICH.J.has(t) ? pJ : (1-pJ));
      axisMatch = axisMatch / 4;

      let dot = 0;
      for(const e of ELEMENTS){
        const pos = MODEL[t].indexOf(e);
        const sign = (pos === 0 || pos === 1) ? +1 : -1;
        dot += (state.elementScores[e]||0) * sign;
      }
      const elementScoreNorm = sigmoid(dot * 0.6 * elemScale);

      const wAxis = 0.62;
      const wElem = 0.34;
      const wPrior = 0.04;
      const combined = wAxis*axisMatch + wElem*elementScoreNorm + wPrior*(1/TYPES.length);
      rawScores[t] = Math.max(1e-12, combined);
    }

    const posteriorRaw = normalizeVec(rawScores);
    const stabilized = stabilizePosterior(posteriorRaw, stepForStabilize || state.step);
    state.posterior = stabilized;

    // compute quadra from posterior
    const qRaw = computeQuadraFromPosterior(state.posterior);

    // compute confidence and optionally mix toward top-type
    const conf = top1Prob(state.posterior);
    const topType = topN(state.posterior,1)[0] ? topN(state.posterior,1)[0][0] : null;
    const qTop = {Alpha:0,Beta:0,Gamma:0,Delta:0};
    if(topType) qTop[QUADRA[topType]] = 1;
    const w = clamp((conf - 0.35) / 0.65, 0, 1);
    const qMixed = {};
    for(const k of Object.keys(qRaw)){
      qMixed[k] = (1-w) * qRaw[k] + w * (qTop[k] || 0);
    }
    const qMixNorm = normalizeVec(qMixed);

    // sharpen quadra for display summary (k tuned later in renderViz as well)
    const kQ = 1 + 6 * conf;
    state.quadra = sharpenDistribution(qMixNorm, kQ);

    return stabilized;
  }

  /* --------------------------
     History logging
     -------------------------- */
  function gapTop2(probs){
    const t = topN(probs,2);
    if(t.length<2) return 1;
    return t[0][1]-t[1][1];
  }

  function recordHistory(optionalIdx){
    const idx = (typeof optionalIdx === "number") ? optionalIdx : state.step;
    const posterior = state.posterior || Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length]));
    const top = topN(posterior,3).map(([t,p])=>({type:t, prob:p}));
    while(top.length<3) top.push({type:"—", prob:0});
    const gap = gapTop2(posterior);
    const H = entropy(posterior);

    const pE = sumSet(posterior, DICH.E);
    const pI = sumSet(posterior, DICH.I);
    const pS = sumSet(posterior, DICH.S);
    const pN = sumSet(posterior, DICH.N);
    const pT = sumSet(posterior, DICH.T);
    const pF = sumSet(posterior, DICH.F);
    const pJ = sumSet(posterior, DICH.J);
    const pP = sumSet(posterior, DICH.P);

    const quadra = state.quadra || computeQuadraFromPosterior(posterior);

    const tempExp = getTemperingExponentForLogging(idx);
    const lam = getStabilizeLam(idx);

    // visual top progression uses sharpened display posterior
    const k = getSharpenK(idx);
    const displayP = sharpenPosterior(posterior, k);
    const topEntry = topN(displayP,1)[0];
    const topTypeName = topEntry ? topEntry[0] : "—";
    const topPct = topEntry ? displayP[topEntry[0]] * 100 : 0;

    state.historyTop1.push(topTypeName);
    state.historyTop1Pct.push(Math.round(topPct * 10) / 10);

    state.historyGap.push(gap);

    state.history.push({
      step: idx,
      top3: top,
      gap: gap,
      entropy: H,
      axes: {pE,pI,pS,pN,pT,pF,pJ,pP},
      quadra: quadra,
      tempExp: tempExp,
      stabilizeLam: lam,
      timestamp: Date.now()
    });
  }

  function getTemperingExponentForLogging(step){
    if(step < 12) return 0.85;
    if(step < 30) return 0.92;
    if(step < 45) return 0.90;
    return 0.86;
  }

  /* --------------------------
     Answer application (kept unchanged)
     -------------------------- */
  function applyResponse(ans, idx){
    const q = QUESTIONS[ans.id];
    if(!q) return;

    if(ans.skipped){
      recordHistory(idx);
      return;
    }

    updateRespStatsLikert(ans.raw);

    if(q.axis){
      const signed = ans.raw * q.weight;
      const dir = q.axisDir;
      if(q.axis === "EI"){
        if(dir === "E"){ state.axisScores.E += signed; state.axisScores.I -= signed; }
        else { state.axisScores.I += signed; state.axisScores.E -= signed; }
      }else if(q.axis === "SN"){
        if(dir === "S"){ state.axisScores.S += signed; state.axisScores.N -= signed; }
        else { state.axisScores.N += signed; state.axisScores.S -= signed; }
      }else if(q.axis === "TF" || q.axis === "FT"){
        if(dir === "T"){ state.axisScores.T += signed; state.axisScores.F -= signed; }
        else { state.axisScores.F += signed; state.axisScores.T -= signed; }
      }else if(q.axis === "JP" || q.axis === "PJ"){
        if(dir === "J"){ state.axisScores.J += signed; state.axisScores.P -= signed; }
        else { state.axisScores.P += signed; state.axisScores.J -= signed; }
      }else{
        if(typeof q.axisDir === "string"){
          const side = q.axisDir;
          if(state.axisScores.hasOwnProperty(side)){
            state.axisScores[side] += signed;
            const oppositeMap = {E:"I",I:"E",S:"N",N:"S",T:"F",F:"T",J:"P",P:"J"};
            const opp = oppositeMap[side];
            if(opp) state.axisScores[opp] -= signed;
          }
        }
      }
    }

    if(q.element && q.element !== "RECAP"){
      state.elementScores[q.element] = (state.elementScores[q.element]||0) + ans.raw * q.weight;
      if(q.phase === 3 && q.dimension){
        const key = `${q.element}::${q.dimension}`;
        state.dimensionScores[key] = (state.dimensionScores[key]||0) + ans.raw * q.weight;
      }
    }

    if(q.element === "RECAP"){
      const elems = Object.entries(state.elementScores).sort((a,b)=>b[1]-a[1]);
      const topElems = elems.slice(0,2).map(x=>x[0]).filter(Boolean);
      for(const te of topElems){
        state.elementScores[te] = (state.elementScores[te]||0) + ans.raw * q.weight * 1.2;
      }
    }

    recomputePosteriorFromScores(idx);
    recordHistory(idx);
  }

  /* --------------------------
     Recompute from start (used when going back)
     -------------------------- */
  function recomputeFromStart(){
    state.posterior = Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length]));
    state.quadra = computeQuadraFromPosterior(state.posterior);
    state.axisScores = {E:0,I:0,S:0,N:0,T:0,F:0,J:0,P:0};
    state.elementScores = Object.fromEntries(ELEMENTS.map(e=>[e,0]));
    state.dimensionScores = {};
    state.respStats = {n:0, mean:0, m2:0, neutral:0, extreme:0};
    state.historyTop1 = [];
    state.historyTop1Pct = [];
    state.historyGap = [];
    state.history = [];

    for(let i=0;i<state.step;i++){
      const a = state.answers[i];
      if(!a) continue;
      applyResponse(a, i);
    }
  }

  /* --------------------------
     UI: scale rendering, question rendering
     -------------------------- */
  function renderScale5(){
    elScale5.innerHTML="";
    SCALE5.forEach(s=>{
      const d=document.createElement("div");
      d.className="opt";
      d.innerHTML=`<span class="dot" aria-hidden="true"></span><span class="lab">${s.label}</span><span class="subv">${s.v>0?("+"+s.v):(""+s.v)}</span>`;
      d.addEventListener("click", ()=>{
        if(state.isAdvancing) return;
        document.querySelectorAll("#scale5 .opt").forEach(x=>x.classList.remove("sel"));
        d.classList.add("sel");
        const id = state.asked[state.step];
        const raw = s.v;
        const ans = {id:id, raw: raw, skipped:false};
        state.answers[state.step] = ans;
        goNext(false);
      });
      elScale5.appendChild(d);
    });
  }

  function renderQuestion(){
    if(state.step >= QUESTIONS.length){
      showResult();
      return;
    }
    const qIndex = state.asked[state.step];
    const q = QUESTIONS[qIndex];

    elQNo.textContent = `Q${state.step+1}`;
    elQText.textContent = q.text || "（質問文が見つかりません）";
    elScale3.style.display = "none";
    elScale5.style.display = "grid";
    renderScale5();

    if(btnNext){ btnNext.style.display = "none"; btnNext.disabled = true; }

    btnBack.disabled = (state.step === 0);

    setProgress();
    updateSide();

    state.isAdvancing = false;
  }

  /* --------------------------
     updateSide - simplified: show only rank + type + quadra label (no % / no mini bar)
     -------------------------- */
  function updateSide(){
    if(!state.livePinned) return;
    const k = getSharpenK(state.step);
    const displayPosterior = sharpenPosterior(state.posterior, k);
    const top = topN(displayPosterior,6);
    topList.innerHTML="";
    top.forEach(([t,p], idx)=>{
      const div=document.createElement("div");
      div.className="rankItem";
      // Only show rank + type + (symbol & name)
      div.innerHTML=`<b>${idx+1}位 ${t} <span style="opacity:.75;font-weight:1100">(${QSYM[QUADRA[t]]} ${QUADRA[t]})</span></b>`;
      topList.appendChild(div);
    });
  }

  /* --------------------------
     renderViz - unified implementation (keep only one)
     - Elements: keep signed centered display (sum 0)
     - Quadra: use state.quadra, sharpen for display with fixed k=3.2 then normalize and show as % with 1 decimal
     -------------------------- */
  function renderViz(topType){
    const posterior = state.posterior || Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length]));

    // valuedProb computation (posterior-weighted)
    const valuedProb = {};
    for(const e of ELEMENTS){
      let s = 0;
      for(const t of TYPES){
        if(QUADRA_VALUES[QUADRA[t]].has(e)) s += (posterior[t] || 0);
      }
      valuedProb[e] = clamp(s, 0, 1);
    }

    // center to -0.5..+0.5 then remove mean to force sum zero
    const raw = {};
    for(const e of ELEMENTS) raw[e] = valuedProb[e] - 0.5;
    const mean = Object.values(raw).reduce((a,b)=>a+b,0)/ELEMENTS.length;
    const centered = {};
    for(const e of ELEMENTS) centered[e] = raw[e] - mean;

    // scale to -50..+50 and round to 10-step
    let maxAbs = Math.max(...Object.values(centered).map(Math.abs)) || 1;
    const score10 = {};
    for(const e of ELEMENTS){
      const scaled = (centered[e]/maxAbs) * 50;
      const step = Math.round(scaled / 10) * 10;
      score10[e] = clamp(step, -50, 50);
    }

    // correct rounding residual so sum==0
    const ssum = Object.values(score10).reduce((a,b)=>a+b,0);
    if(ssum !== 0){
      const maxElem = Object.entries(score10).reduce((acc,cur)=>{
        if(!acc) return cur;
        return Math.abs(cur[1]) > Math.abs(acc[1]) ? cur : acc;
      }, null);
      if(maxElem){
        score10[maxElem[0]] = clamp(score10[maxElem[0]] - ssum, -50, 50);
      }
    }

    // elementViz build
    const el = document.getElementById("elementViz");
    if(el){
      el.innerHTML = ELEMENTS.map(e=>{
        const val = score10[e];
        const isValued = valuedProb[e] >= 0.5;
        const labelVal = isValued ? "価値寄り" : "非価値寄り";
        const pctText = (val>0?"+":"") + String(val) + "%";
        const leftPct = val < 0 ? Math.abs(val) : 0;
        const rightPct = val > 0 ? val : 0;
        return `
          <div class="vizRow">
            <b>${e} <span style="font-weight:700;font-size:12px;color:var(--muted);">(${labelVal})</span></b>
            <div class="vizBarSplit">
              <div class="centerLine" aria-hidden="true"></div>
              <div class="barWrap" style="width:100%;">
                <div style="flex:1;display:flex;justify-content:flex-end;padding-right:4px">
                  <div style="width:${leftPct}%;max-width:50%;"><div class="neg" style="width:100%"></div></div>
                </div>
                <div style="flex:1;display:flex;justify-content:flex-start;padding-left:4px">
                  <div style="width:${rightPct}%;max-width:50%;"><div class="pos" style="width:100%"></div></div>
                </div>
              </div>
            </div>
            <div class="vizPct" style="width:80px;text-align:right">${pctText}</div>
          </div>
        `;
      }).join("");
    }

    // Quadra display: start from state.quadra, apply sharpenDistribution with k = 3.2, normalize, then show percentages (1 decimal)
    const qRaw = state.quadra || computeQuadraFromPosterior(posterior);
    const qSharp = sharpenDistribution(qRaw, 3.2); // fixed sharpening for visible bias
    const qDisplay = normalizeVec(qSharp);

    const qvEl = document.getElementById("quadraViz");
    if(qvEl){
      const order = ["Alpha","Beta","Gamma","Delta"];
      qvEl.innerHTML = order.map(q=>{
        const pct = (Math.round(clamp(qDisplay[q],0,1)*1000)/10).toFixed(1);
        return `
          <div class="vizRow">
            <b>${QSYM[q]} ${q}</b>
            <div class="vizBar"><i style="width:${pct}%"></i></div>
            <div class="vizPct">${pct}%</div>
          </div>
        `;
      }).join("");
    }
  }

  /* --------------------------
     Results display (kept UX but using display sharpening for headline)
     -------------------------- */
  function adjustDisplayPercentages(topRaw){
    const mins=[60,20,1];
    const maxs=[90,40,20];
    const slots = topRaw.map(x=>x[1] || 0);
    while(slots.length<3) slots.push(0);
    const sum = slots.reduce((a,b)=>a+b,0) || 1;
    let w = slots.map(s=>s/sum);

    let remain = 100 - mins.reduce((a,b)=>a+b,0);
    let alloc = mins.map((m,i)=> m + remain * w[i]);

    for(let iter=0; iter<8; iter++){
      let excess = 0;
      const slack = [];
      for(let i=0;i<3;i++){
        if(alloc[i] > maxs[i]){ excess += alloc[i] - maxs[i]; alloc[i] = maxs[i]; }
        else slack.push(i);
      }
      if(excess <= 1e-6) break;
      if(slack.length===0) break;
      const totalSlack = slack.reduce((s,i)=>s + (maxs[i]-alloc[i]),0) || 1;
      for(const i of slack){
        alloc[i] += (maxs[i]-alloc[i]) / totalSlack * excess;
      }
    }

    const rounded = alloc.map(x=>Math.round(x));
    let diff = 100 - rounded.reduce((a,b)=>a+b,0);
    const order = [0,1,2];
    for(let i=0;i<Math.abs(diff); i++){
      const idx = order[i % order.length];
      if(diff>0){
        if(rounded[idx] < maxs[idx]) rounded[idx] += 1;
        else {
          for(const j of order) if(rounded[j] < maxs[j]) { rounded[j] += 1; break; }
        }
      }else{
        if(rounded[idx] > mins[idx]) rounded[idx] -= 1;
        else {
          for(const j of order) if(rounded[j] > mins[j]) { rounded[j] -= 1; break; }
        }
      }
    }
    for(let i=0;i<3;i++) rounded[i] = Math.max(mins[i], Math.min(maxs[i], rounded[i]));
    let ssum = rounded.reduce((a,b)=>a+b,0);
    if(ssum !== 100) rounded[0] += 100 - ssum;
    return rounded;
  }

  /* --------------------------
     UI wiring & flow controls
     -------------------------- */
  if(btnNext){ btnNext.style.display = "none"; btnNext.disabled = true; }

  btnSkip.addEventListener("click", ()=>{
    if(state.isAdvancing) return;
    document.querySelectorAll("#scale5 .opt, #scale3 .opt").forEach(x=>x.classList.remove("sel"));
    const id = state.asked[state.step];
    const ans = {id:id, raw:0, skipped:true};
    state.answers[state.step] = ans;
    goNext(true);
  });

  btnBack.addEventListener("click", ()=>{
    if(state.isAdvancing) return;
    goBack();
  });

  document.getElementById("btnRestart").addEventListener("click", ()=>location.reload());
  document.getElementById("btnRestartTop").addEventListener("click", ()=>location.reload());

  btnToggleLive.addEventListener("click", ()=>{ 
    state.livePinned = !state.livePinned;
    if(state.livePinned){ sideCard.classList.remove("hidden"); btnToggleLive.textContent="上位候補を非表示"; updateSide(); }
    else { sideCard.classList.add("hidden"); btnToggleLive.textContent="上位候補を表示"; }
  });

  const btnToggleFeedback = document.getElementById("btnToggleFeedback");
  const feedbackContent = document.getElementById("feedbackContent");
  if(btnToggleFeedback && feedbackContent){
    btnToggleFeedback.addEventListener("click", ()=>{
      const open = feedbackContent.classList.contains("hidden");
      if(open){ feedbackContent.classList.remove("hidden"); btnToggleFeedback.textContent="閉じる"; }
      else { feedbackContent.classList.add("hidden"); btnToggleFeedback.textContent="開く"; }
    });
  }

  /* --------------------------
     Flow helpers
     -------------------------- */
  function goNext(skipped=false){
    if(state.isAdvancing) return;
    state.isAdvancing = true;

    if(skipped){
      const id = state.asked[state.step];
      const ans = {id:id, raw:0, skipped:true};
      state.answers[state.step] = ans;
      applyResponse(ans, state.step);
    }else{
      const ans = state.answers[state.step];
      if(!ans){
        state.isAdvancing = false;
        return;
      }
      applyResponse(ans, state.step);
    }

    state.step += 1;

    if(state.step >= QUESTIONS.length){
      showResult();
      return;
    }
    renderQuestion();
  }

  function goBack(){
    if(state.step<=0) return;
    state.step -= 1;
    recomputeFromStart();
    renderQuestion();
  }

  function showResult(){
    try{
      recomputeFromStart();

      screenQuiz.style.display = "none";
      screenResult.style.display = "block";

      const topRaw = topN(state.posterior,3);
      while(topRaw.length<3) topRaw.push(["—",0]);

      // For headline display we use a display-sharpened posterior
      const kFinal = getSharpenK(state.step);
      const displayP = sharpenPosterior(state.posterior, kFinal);
      const displayForTop = topRaw.map(entry => [entry[0], displayP[entry[0]] || 0]);
      const displayPcts = adjustDisplayPercentages(displayForTop);

      const top3 = topRaw.map((entry,i)=> {
        const t = entry[0];
        return {type:t, displayPct: displayPcts[i]};
      });

      document.getElementById("resHeadline").textContent =
        top3.map((e,idx)=>`${idx+1}位 ${e.type}（${e.displayPct}%）`).join(" / ");

      const resCards=document.getElementById("resCards");
      resCards.innerHTML = "";
      top3.forEach((tp, idx)=>{
        const t = tp.type;
        const p = tp.displayPct;
        const s = typeSummary(t);
        const div = document.createElement("div");
        div.className = "qbox";
        div.innerHTML = `
          <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
            <div>
              <div class="small">${idx+1}位</div>
              <div style="font-size:18px;font-weight:1200;margin-top:4px">${t}
                <span style="font-size:11px;color:var(--muted);border:1px solid var(--line);background:rgba(10,20,40,.04);border-radius:999px;padding:4px 8px;margin-left:8px">
                  ${QSYM[s.quadra]} ${s.quadra}
                </span>
              </div>
            </div>
            <div style="font-weight:1200">${p}%</div>
          </div>
          <div class="hr"></div>
          <div class="small">
            主導：<b style="color:var(--ink)">${s.lead}</b> ／ 創造：<b style="color:var(--ink)">${s.crea}</b><br/>
            価値：${s.values}
          </div>
          <div style="margin-top:10px;line-height:1.9">${s.oneLine}</div>
        `;
        resCards.appendChild(div);
      });

      const topType = top3[0]?.type || topN(state.posterior,1)[0]?.[0] || "ILE";
      renderViz(topType);
      showFeedback(topType);
      updateSide();

      const exportBtn = document.getElementById("btnExportData");
      if(exportBtn){
        exportBtn.addEventListener("click", async ()=>{
          const data = {
            answers: state.answers,
            history: state.history,
            finalPosterior: state.posterior,
            asked: state.asked,
            historyTop1: state.historyTop1,
            historyTop1Pct: state.historyTop1Pct,
            metadata: {timestamp: new Date().toISOString(), stepCount: state.step, version: "v2.1.1-stable"}
          };
          const json = JSON.stringify(data, null, 2);
          let didCopy = false;
          try{
            if(navigator.clipboard && navigator.clipboard.writeText){
              await navigator.clipboard.writeText(json);
              didCopy = true;
            }
          }catch(e){ didCopy = false; }
          try{
            const blob = new Blob([json], {type:"application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            const pad=(n)=>String(n).padStart(2,"0");
            const dt=new Date();
            const filename = `socionics-diagnostic-${dt.getFullYear()}${pad(dt.getMonth()+1)}${pad(dt.getDate())}-${pad(dt.getHours())}${pad(dt.getMinutes())}${pad(dt.getSeconds())}.json`;
            a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
          }catch(e){
            const w = window.open("");
            if(w) w.document.body.textContent = json;
          }
          const oldText = exportBtn.textContent;
          exportBtn.textContent = didCopy ? "クリップボードにコピー済" : "保存しました";
          setTimeout(()=>{ exportBtn.textContent = oldText; }, 2200);
        }, {once:true});
      }

    }catch(e){
      const be = document.getElementById("bootError");
      if(be){ be.classList.remove("hidden"); be.textContent = String(e); }
    }finally{
      state.isAdvancing = false;
    }
  }

  /* --------------------------
     typeSummary & feedback helpers (kept)
     -------------------------- */
  function typeSummary(t){
    const q=QUADRA[t];
    const lead=MODEL[t][0], crea=MODEL[t][1];
    const values=[...QUADRA_VALUES[q]].join("・");
    const oneLine = {
      ILE:"アイデアを広げ、体系化しながら論理を構築",
      SEI:"快適さと空気を整え、調整と安定。",
      ESE:"雰囲気を温めつつ現実も回す。人を巻き込みながら整える。",
      LII:"概念の整理と整合性が強い。体系化・矛盾修正。",
      EIE:"流れの意味を掴み、感情表現で推進する。熱量と物語。",
      LSI:"規律と境界を保ち、運用で守る。ぶれない秩序。",
      SLE:"主導して切り開く実行力。決断と突破。",
      IEI:"流れと空気を読み、タイミングを作る。洞察と共鳴。",
      SEE:"関係と主導で現実を動かす。交渉・推進。",
      ILI:"流れを読み、実務を選別する。先読み×現実処理。",
      LIE:"目的へ最短で進む設計。成果へ落とす。",
      ESI:"誠実さと境界で関係を整える。筋と責任。",
      LSE:"実務と環境調整で安定推進。堅実に回す。",
      EII:"関係の質と可能性を大事にする。誠実×成長。",
      IEE:"可能性と関係で新展開を作る。接続と発想。",
      SLI:"快適さと実務で無理なく最適化。静かな改善。"
    }[t]||"—";
    return {quadra:q, lead, crea, values, oneLine};
  }

  function showFeedback(topType){
    try{
      const fbQuadEl = document.getElementById("fbQuadra");
      const fbValuesEl = document.getElementById("fbValues");
      const fbStrongEl = document.getElementById("fbStrong");
      const fbMismatchEl = document.getElementById("fbMismatch");
      if(!fbQuadEl || !fbValuesEl || !fbStrongEl || !fbMismatchEl) return;

      const q = QUADRA[topType];
      const values = [...QUADRA_VALUES[q]];
      const posterior = state.posterior || Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length]));
      const valuedProb = {};
      for(const e of ELEMENTS){
        let s = 0;
        for(const t of TYPES){
          if(QUADRA_VALUES[QUADRA[t]].has(e)) s += (posterior[t] || 0);
        }
        valuedProb[e] = +(s.toFixed(2));
      }
      const norm = valuedProb;
      const strong = Object.entries(norm).sort((a,b)=>b[1]-a[1]).slice(0,3).filter(([_,v])=>v>0.62);
      const mismatch = Object.entries(norm).sort((a,b)=>a[1]-b[1]).slice(0,5).filter(([_,v])=>v<0.38);

      fbQuadEl.textContent = `このクアドラは ${q} の傾向があります。`;
      fbValuesEl.innerHTML = `このクアドラは <b>${values.map(e=>e).join(" / ")}</b> を扱いやすい傾向です。`;

      fbStrongEl.innerHTML =
        (strong.length===0)
        ? "明確に強まった要素は見られません。"
        : "特に一致していた要素：<br>" +
          strong.map(([e,v])=>`・<b>${e}</b>（${v}）`).join("<br>");

      fbMismatchEl.innerHTML =
        (mismatch.length===0)
        ? "目立ったズレはありませんでした。"
        : "ズレが見られた要素：<br>" + mismatch.map(([e,v])=>`・<b>${e}</b>（${v}）`).join("<br>");
    }catch(e){
      // defensive
    }
  }

  /* --------------------------
     Startup
     -------------------------- */
  function boot(){
    state.posterior = Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length]));
    state.quadra = computeQuadraFromPosterior(state.posterior);
    renderQuestion();
  }

  try{ boot(); }catch(e){
    const be=document.getElementById("bootError");
    if(be){ be.classList.remove("hidden"); be.textContent = String(e); }
  }

})();
</script>
</body>
</html>

