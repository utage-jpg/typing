<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<title>Socionics Adaptive Typing (50Q / 100 Bank)</title>
<meta name="theme-color" content="#0ea5e9" />
<style>
:root{
  --bg:#ffffff; --panel:#f8fafc; --ink:#0f172a; --muted:#64748b; --line:#e2e8f0; --hi:#0ea5e9;
  --card:#ffffff; --shadow:0 8px 22px rgba(2,6,23,.06);
}
*{box-sizing:border-box}
html,body{margin:0;background:var(--bg);color:var(--ink);
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Hiragino Sans","Noto Sans JP","Yu Gothic",Meiryo,sans-serif}
a{color:#0b74c7;text-decoration:none}
a:hover{text-decoration:underline}

.wrap{max-width:980px;margin:0 auto;padding:14px;display:grid;gap:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow)}
.hd{padding:12px 14px;border-bottom:1px solid var(--line);display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.hd h1{margin:0;font-size:16px;letter-spacing:.2px}
.small{font-size:12px;color:var(--muted)}
.body{padding:14px;display:grid;gap:12px}

.progressRow{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.bar{flex:1;min-width:220px;height:10px;background:var(--panel);border:1px solid var(--line);border-radius:999px;overflow:hidden}
.bar > div{height:100%;width:0%;background:var(--hi)}
.badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--line);background:var(--panel);font-size:12px;color:#334155}

.qbox{border:1px solid var(--line);border-radius:14px;padding:14px;background:#fff}
.qno{font-weight:900;font-size:12px;color:#334155}
.qtext{font-size:16px;line-height:1.7;margin:8px 0 12px}
.scale{display:grid;gap:8px}
@media(min-width:740px){
  .scale{grid-template-columns:repeat(5,1fr)}
}
.opt{
  border:1px solid var(--line); border-radius:12px; padding:10px;
  background:#fff; cursor:pointer; user-select:none;
  display:flex; align-items:center; gap:10px; min-height:46px;
  transition:.12s;
}
.opt:hover{transform:translateY(-1px); box-shadow:0 8px 18px rgba(2,6,23,.06)}
.dot{width:16px;height:16px;border-radius:999px;border:2px solid #94a3b8;display:inline-block;position:relative;flex:0 0 auto}
.opt.sel{border-color:#93c5fd; box-shadow:0 0 0 4px rgba(147,197,253,.25)}
.opt.sel .dot{border-color:var(--hi)}
.opt.sel .dot::after{content:"";position:absolute;inset:3px;border-radius:999px;background:var(--hi)}
.lab{font-size:13px;color:#0f172a;font-weight:700}
.sub{font-size:11px;color:var(--muted);margin-left:auto}

.controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}
.btn{
  padding:10px 12px;border:1px solid var(--line);border-radius:12px;background:#fff;
  font-weight:800;cursor:pointer;user-select:none;min-height:42px
}
.btn.primary{background:var(--hi);color:#fff;border-color:transparent}
.btn:active{transform:scale(.99)}
.btn[disabled]{opacity:.5;cursor:not-allowed}

.resultTop{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.linkRow{display:flex;gap:10px;flex-wrap:wrap}
.linkBtn{
  display:inline-flex;align-items:center;gap:8px;
  border:1px solid #cfe8ff;background:#f0f7ff;color:#0b74c7;
  padding:10px 12px;border-radius:12px;font-weight:900
}
.note{font-size:12px;color:var(--muted);line-height:1.7}
</style>
</head>
<body>
<div class="wrap">
  <div class="card" id="app">
    <div class="hd">
      <h1>ソシオニクスタイピング</h1>
      <div class="small">結果は最後にのみ表示されます</div>
    </div>

    <div class="body" id="screenQuiz">
      <div class="progressRow">
        <div class="bar" aria-label="progress"><div id="barFill"></div></div>
        <div class="badge">進捗：<b id="progText">0 / 50</b></div>
      </div>

      <div class="qbox">
        <div class="qno" id="qNo">Q1</div>
        <div class="qtext" id="qText">—</div>

        <div class="scale" id="scale"></div>

        <div class="controls" style="margin-top:12px">
          <button class="btn" id="btnBack" disabled>戻る</button>
          <button class="btn" id="btnSkip">わからない</button>
          <button class="btn primary" id="btnNext" disabled>次へ</button>
        </div>

        <div class="note" style="margin-top:10px">
          ※「わからない」はスコアに影響させず、別の問題に切り替えます。<br/>
          ※ 次元・クアドラ等の推定は内部ロジックのみで利用し、画面表示しません。
        </div>
      </div>
    </div>

    <div class="body" id="screenResult" style="display:none">
      <div class="resultTop">
        <div>
          <div class="small">結果（上位3タイプ）</div>
          <h2 style="margin:6px 0 0;font-size:20px" id="resHeadline">—</h2>
        </div>
        <div class="linkRow">
          <a class="linkBtn" id="linkViewer" target="_blank" rel="noopener">タイプ即時ビュー（プレビュー）</a>
          <a class="linkBtn" id="linkFunc" target="_blank" rel="noopener">機能×情報要素（プレビュー）</a>
          <button class="btn" id="btnRestart">最初から</button>
        </div>
      </div>

      <div class="note" style="margin-top:6px">
        ここでは「推定タイプの要点」と「Model A の核（主導・創造・価値）」のみを簡潔に表示します。詳細はプレビュー先へ。
      </div>

      <div id="resCards" style="margin-top:12px;display:grid;gap:10px"></div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   0) 既存ツールへのリンク（安定版）
   ========================================================= */
const VIEWER_NAME = "【完成版】ソシオまとめビューア.html";
const FUNC_NAME   = "【完成版】機能×情報要素.html";
document.getElementById("linkViewer").href = new URL(encodeURI(VIEWER_NAME), location.href).href;
document.getElementById("linkFunc").href   = new URL(encodeURI(FUNC_NAME),   location.href).href;

/* =========================================================
   1) 型・Model A（既存ツール整合）
   ========================================================= */
const TYPES_UI=["ILE","SEI","ESE","LII","EIE","LSI","SLE","IEI","SEE","ILI","LIE","ESI","LSE","EII","IEE","SLI"];
const ELEMENTS = ["Te","Ti","Fe","Fi","Ne","Ni","Se","Si"];

const QUADRA={
  ILE:"Alpha", SEI:"Alpha", ESE:"Alpha", LII:"Alpha",
  EIE:"Beta",  LSI:"Beta",  SLE:"Beta",  IEI:"Beta",
  SEE:"Gamma", ILI:"Gamma", LIE:"Gamma", ESI:"Gamma",
  IEE:"Delta", SLI:"Delta", LSE:"Delta", EII:"Delta"
};
const QSYM={Alpha:"α",Beta:"β",Gamma:"γ",Delta:"Δ"};

const MODEL={
  // Alpha
  ILE:["Ne","Ti","Se","Fi","Si","Fe","Ni","Te"],
  SEI:["Si","Fe","Ni","Te","Ne","Ti","Se","Fi"],
  ESE:["Fe","Si","Te","Ni","Ti","Ne","Fi","Se"],
  LII:["Ti","Ne","Fi","Se","Fe","Si","Te","Ni"],
  // Beta
  EIE:["Fe","Ni","Te","Si","Ti","Se","Fi","Ne"],
  SLE:["Se","Ti","Ne","Fi","Ni","Fe","Si","Te"],
  LSI:["Ti","Se","Fi","Ne","Fe","Ni","Te","Si"],
  IEI:["Ni","Fe","Si","Te","Se","Ti","Ne","Fi"],
  // Gamma
  SEE:["Se","Fi","Ne","Ti","Ni","Te","Si","Fe"],
  ILI:["Ni","Te","Si","Fe","Se","Fi","Ne","Ti"],
  LIE:["Te","Ni","Fe","Si","Fi","Se","Ti","Ne"],
  ESI:["Fi","Se","Ti","Ne","Te","Ni","Fe","Si"],
  // Delta
  SLI:["Si","Te","Ni","Fe","Ne","Fi","Se","Ti"],
  IEE:["Ne","Fi","Se","Ti","Si","Te","Ni","Fe"],
  LSE:["Te","Si","Fe","Ni","Fi","Ne","Ti","Se"],
  EII:["Fi","Ne","Ti","Se","Te","Si","Fe","Ni"]
};

const DIM_BY_POS=["4","3","2","1","1","2","3","4"]; // pos:1..8

const QUADRA_VALUES={
  Alpha:new Set(["Ne","Ti","Fe","Si"]),
  Beta :new Set(["Fe","Ni","Se","Ti"]),
  Gamma:new Set(["Fi","Te","Se","Ni"]),
  Delta:new Set(["Si","Te","Fi","Ne"])
};

/* =========================================================
   2) 設問バンク（100問）
   ========================================================= */
const BANK = [];
function addV(e, text, dir=+1){ BANK.push({kind:"v", element:e, dir, text}); }
function addD(e, text, dir=+1){ BANK.push({kind:"d", element:e, dir, text}); }
function addB(text, wMap, dir=+1){ BANK.push({kind:"b", element:null, dir, text, wMap}); }

// ---- 価値/非価値：64問（v） ----
// Ne（書き換え済み）
addV("Ne","ひらめいた案があると、現実的かは後で考えて、まず口に出したくなります。",+1);
addV("Ne","話題が一つに固定されると、別の例えや別の見方を足したくなります。",+1);
addV("Ne","未経験でも、「やってみたら面白そう」が最初に出やすいです。",+1);
addV("Ne","選べるものが少ないと、ちょっと息が詰まる感じがします。",+1);
addV("Ne","アイデアを増やすより、早めに一つに決めて進めたいです。",-1);
addV("Ne","可能性の話より、「今すぐできること」を詰めた方が落ち着きます。",-1);
addV("Ne","予定が決まっていない段階のふわっとした相談は、少し苦手です。",-1);
addV("Ne","別案を出すより、結論まで一直線に進めたいことが多いです。",-1);

// Ni（書き換え済み）
addV("Ni","目の前の出来事から、数週間〜数か月先の展開を自然に想像してしまいます。",+1);
addV("Ni","「なぜ起きたか」より、「この流れはどこへ向かうか」が気になります。",+1);
addV("Ni","急いで決めるより、少し時間を置いて全体像を見たくなります。",+1);
addV("Ni","タイミングがずれると、理由は説明できなくても違和感が残ります。",+1);
addV("Ni","先のことを考えすぎるより、今すぐ手を動かしたいです。",-1);
addV("Ni","“流れ”より、手順やチェックリストがある方が安心します。",-1);
addV("Ni","長期の話が続くと、「今の現実の話に戻そう」と思います。",-1);
addV("Ni","雰囲気や兆しより、はっきりした根拠がないと判断しません。",-1);

// Se（書き換え済み）
addV("Se","迷っている人を見ると、「まず決めて動こう」と背中を押したくなります。",+1);
addV("Se","必要なら、少し強めに言ってでも前に進めた方が良いと思います。",+1);
addV("Se","交渉や勝負どころでは、遠慮より主導権が大事だと感じます。",+1);
addV("Se","空気に左右されず、言うべきことは言って状況を動かしたいです。",+1);
addV("Se","強く出るより、揉めない形で合意を作りたいです。",-1);
addV("Se","押し切るより、相手が自然に納得するのを待ちたいです。",-1);
addV("Se","「勝つ／負ける」みたいな空気が濃い場は、疲れやすいです。",-1);
addV("Se","緊張感がある場面では、前に出るより一歩引いて様子を見がちです。",-1);

// Si（書き換え済み）
addV("Si","効率より先に、「無理なく続けられる状態」を整えたくなります。",+1);
addV("Si","温度・匂い・姿勢などの小さな不快があると、集中が落ちやすいです。",+1);
addV("Si","予定を詰めすぎると反動が来るので、前もって調整したくなります。",+1);
addV("Si","生活が整っているかどうかで、その日の機嫌や調子が左右されます。",+1);
addV("Si","快適さより、多少きつくても前に進めたいです。",-1);
addV("Si","体調や環境より、目的達成のスピードを優先しがちです。",-1);
addV("Si","細かい調整は苦手で、まとめて一気に片付けたいです。",-1);
addV("Si","居心地の良さより、刺激や変化がある方が楽しいです。",-1);

// Ti（書き換え済み）
addV("Ti","話の言葉の意味がズレていると、内容より先にそこが気になります。",+1);
addV("Ti","「なんとなく」より、「筋が通っているか」を重視して判断しがちです。",+1);
addV("Ti","説明するとき、前提→論点→結論の順に整えたくなります。",+1);
addV("Ti","ルールや枠組みが曖昧だと、不安定に感じます。",+1);
addV("Ti","細かい整合性より、勢いや現場の感覚で進めたいです。",-1);
addV("Ti","定義にこだわる議論を見ると、少し面倒に感じます。",-1);
addV("Ti","筋よりも、「結果が出るか」を優先したいです。",-1);
addV("Ti","仕組みを整えるより、その場その場で最適に対応したいです。",-1);

// Te（書き換え済み）
addV("Te","話が抽象的になると、数字・期限・手順に落として考えたくなります。",+1);
addV("Te","やり方が複数あるなら、まず「最短で成果が出る方法」を探します。",+1);
addV("Te","成果が見えない作業を続けるのは、ストレスになりやすいです。",+1);
addV("Te","情報を集めるとき、評判より実績や比較データが気になります。",+1);
addV("Te","効率より、納得感や人との関係を優先したいです。",-1);
addV("Te","数字やKPIの話が続くと、空気が乾く感じがします。",-1);
addV("Te","成果だけでなく、過程で大事にしたい価値があると思います。",-1);
addV("Te","すぐ結論を出すより、まず話して温度感を合わせたいです。",-1);

// Fe（書き換え済み）
addV("Fe","場が静かすぎると、少しでも空気を動かしたくなります。",+1);
addV("Fe","相手のテンションに合わせて、声のトーンやリアクションが変わります。",+1);
addV("Fe","正しさより、「場がいい感じに回るか」を優先することがあります。",+1);
addV("Fe","気持ちを言葉にして共有すると、距離が縮まる感じがします。",+1);
addV("Fe","感情表現が多い場は、情報が多くて疲れやすいです。",-1);
addV("Fe","ノリより、淡々と本題を進めたいです。",-1);
addV("Fe","気持ちは言葉より、行動で示す方が楽です。",-1);
addV("Fe","盛り上げ役を期待されると、負担に感じます。",-1);

// Fi（書き換え済み）
addV("Fi","人を見るとき、能力より「誠実さ」「信頼できるか」を重視します。",+1);
addV("Fi","距離感が近すぎる／遠すぎる、という違和感に気づきやすいです。",+1);
addV("Fi","立場が違っても、約束や筋は守るべきだと思います。",+1);
addV("Fi","何かを頼むとき、関係性を考えて言い方を選びます。",+1);
addV("Fi","関係性より、役割や成果で割り切った方が楽です。",-1);
addV("Fi","相手の気持ちを読むより、事実と条件を揃えたいです。",-1);
addV("Fi","「ちょうどいい距離感」を考えるのは得意ではありません。",-1);
addV("Fi","少しドライでも、目的が達成できれば問題ないと思います。",-1);

// ---- 次元：24問（d） ----
addD("Te","慣れない分野でも、比較表や手順化で“使える形”に落とせます。",+1);
addD("Te","急に成果や数字を求められても、落ち着いて現実的な案を出せます。",+1);
addD("Te","実務の話になると、経験がないと途端に自信がなくなります。",-1);

addD("Ti","初見の議題でも、前提と論点を整理して矛盾を見つけられます。",+1);
addD("Ti","複雑な話でも、分類や定義づけでシンプルにできます。",+1);
addD("Ti","論理の突っ込みが来ると、頭が真っ白になりやすいです。",-1);

addD("Fe","空気が荒れていても、温度を読んで落とし所を作れます。",+1);
addD("Fe","相手の反応を見ながら、言い方やテンポをその場で調整できます。",+1);
addD("Fe","感情のやり取りが続くと、どうしていいかわからなくなります。",-1);

addD("Fi","関係がこじれた時、境界線を保ちつつ修復する方針を作れます。",+1);
addD("Fi","相手の立場が変わっても、距離感をうまく調整できます。",+1);
addD("Fi","人間関係の揉め事は、なるべく見ないふりをしたくなります。",-1);

addD("Ne","行き詰まりのとき、別解や例外パターンを複数出せます。",+1);
addD("Ne","未知の領域でも、仮説を置いて探索を進められます。",+1);
addD("Ne","選択肢が増えると、かえって動けなくなります。",-1);

addD("Ni","状況の“兆し”から、先回りして準備や方向転換ができます。",+1);
addD("Ni","短期の雑音に惑わされず、流れの主題を掴めます。",+1);
addD("Ni","先読みを求められると、不安になって避けたくなります。",-1);

addD("Se","抵抗があっても、必要な場面なら押し切る実行ができます。",+1);
addD("Se","対立場面でも、自分の立場を保って交渉できます。",+1);
addD("Se","強く出る必要があると、萎縮してしまいます。",-1);

addD("Si","忙しくても、自分や周囲の負担が破綻しないよう微調整できます。",+1);
addD("Si","“居心地”の差を言語化して改善提案できます。",+1);
addD("Si","体調や快適さの調整は後回しにして、限界まで走りがちです。",-1);

// ---- 補助：12問（b） ----
addB("人が多い場の後、元気が増えるというより“消耗して静かな時間が欲しくなる”ことが多いです。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (["ILI","IEI","LII","EII","SLI","SEI","ILE","IEE"].includes(t)? +1 : -1 )])), +1);
addB("新しい人間関係に飛び込むより、既にある関係を深める方が落ち着きます。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (["EII","ESI","LSI","LII","SLI","ILI","SEI","IEI"].includes(t)? +1 : -1 )])), +1);
addB("予定や段取りが固まってから動く方が安心です。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (["LSE","LIE","ESE","EIE","LSI","LII","ESI","EII"].includes(t)? +1 : -1 )])), +1);
addB("細かい計画より、状況を見ながら柔軟に変える方が得意です。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (["ILE","IEE","SEI","SLI","SLE","SEE","IEI","ILI"].includes(t)? +1 : -1 )])), +1);
addB("議論の場で、感情の納得より“筋が通っているか”を優先しがちです。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (["LII","LSI","ILE","SLE","LSE","LIE","ILI","SLI"].includes(t)? +1 : -1 )])), +1);
addB("正しさより、相手がどう感じるか（関係がどうなるか）を優先しがちです。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (["EII","ESI","IEE","SEE","ESE","EIE","SEI","IEI"].includes(t)? +1 : -1 )])), +1);
addB("議論は重くしすぎず、アイデアや冗談で軽快に回る方が好きです。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (QUADRA[t]==="Alpha"? +1 : -1)])), +1);
addB("集団で熱量を揃え、勢いを作って突破する空気にワクワクします。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (QUADRA[t]==="Beta"? +1 : -1)])), +1);
addB("目的と責任範囲が明確で、実利のある話が一番落ち着きます。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (QUADRA[t]==="Gamma"? +1 : -1)])), +1);
addB("大きなドラマより、生活や環境を整えながらじわっと良くするのが好きです。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (QUADRA[t]==="Delta"? +1 : -1)])), +1);
addB("衝突を避けるために、言い方や空気を優先してしまうことがあります。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (["ESE","EIE","IEI","SEI"].includes(t)? +1 : -1)])), +1);
addB("甘い言葉より、具体的な行動や結果で信頼を積む方が自然です。",
  Object.fromEntries(TYPES_UI.map(t=>[t, (["LSE","LIE","ILI","SLI","LSI","SLE"].includes(t)? +1 : -1 )])), +1);

if(BANK.length !== 100){
  console.warn("BANK length is", BANK.length, "(expected 100)");
}

/* =========================================================
   3) 回答スケール
   ========================================================= */
const TARGET_Q = 50;
const SCALE = [
  {label:"そう思う",           v:+2},
  {label:"部分的にそう思う",   v:+1},
  {label:"中立",               v: 0},
  {label:"あまりそう思わない", v:-1},
  {label:"全くそう思わない",   v:-2},
];

/* =========================================================
   4) 状態
   ========================================================= */
const state = {
  step: 0,
  askedIds: [],
  answers: [],
  stats: Object.fromEntries(ELEMENTS.map(e => [e, {vSum:0, vN:0, dSum:0, dN:0}])),
  scores: Object.fromEntries(TYPES_UI.map(t=>[t, 0])),
  elemCount: Object.fromEntries(ELEMENTS.map(e => [e, 0])),
  _pending: null,
};

/* =========================================================
   5) ユーティリティ
   ========================================================= */
function softmaxWithTemp(scores, temp=2.6){
  const scaled = Object.fromEntries(Object.entries(scores).map(([k,v])=>[k, v/temp]));
  const mx = Math.max(...Object.values(scaled));
  const exps = Object.fromEntries(Object.entries(scaled).map(([k,v])=>[k, Math.exp(v-mx)]));
  const sum = Object.values(exps).reduce((a,b)=>a+b,0);
  return Object.fromEntries(Object.entries(exps).map(([k,v])=>[k, v/sum]));
}

function topN(probs, n=3){
  return Object.entries(probs).sort((a,b)=>b[1]-a[1]).slice(0,n);
}

function formatTop3ForDisplay(top3){
  const floor = 0.01;
  const cap   = 0.98;

  const sum = top3.reduce((s, x)=>s + x[1], 0) || 1;
  let p = top3.map(x => x[1] / sum);

  let rem = 1 - 3*floor; // 0.97
  p = p.map(x => floor + rem*x);

  if(p[0] > cap){
    const rest = 1 - cap;
    p[0] = cap;

    const r2 = Math.max(p[1]-floor, 0);
    const r3 = Math.max(p[2]-floor, 0);
    const rsum = r2 + r3;

    if(rsum > 0){
      p[1] = floor + rest * (r2/rsum);
      p[2] = floor + rest * (r3/rsum);
    }else{
      p[1] = floor;
      p[2] = floor;
    }
  }
  return top3.map((x,i)=>[x[0], Math.round(p[i]*100)]);
}

/* =========================================================
   6) 出題識別力（既存の重み式：価値>次元>補助）
   ========================================================= */
function elementPos(type, element){ return MODEL[type].indexOf(element); } // 0..7
function elementDim(type, element){
  const pos = elementPos(type, element);
  if(pos<0) return 2;
  return parseInt(DIM_BY_POS[pos],10); // 1..4
}
function isValued(type, element){
  const q = QUADRA[type];
  return QUADRA_VALUES[q].has(element);
}
function weightForQuestion(type, q){
  const Wv=3.0, Wd=2.0, Wb=1.0;

  if(q.kind==="b"){
    const w = (q.wMap && (q.wMap[type] ?? 0)) || 0;
    return Wb * 0.55 * w * q.dir;
  }

  const e=q.element;
  if(!e) return 0;

  if(q.kind==="v"){
    const sign = isValued(type,e) ? +1 : -1;
    return Wv * sign * q.dir;
  }

  if(q.kind==="d"){
    const dim = elementDim(type,e);
    const dimScore = {1:-1.2, 2:0.2, 3:0.9, 4:1.3}[dim] ?? 0.2;
    return Wd * dimScore * q.dir;
  }
  return 0;
}

function varianceWeighted(values, probs){
  const mu = Object.keys(values).reduce((s,t)=>s + values[t]*probs[t], 0);
  return Object.keys(values).reduce((s,t)=>{
    const d = values[t]-mu;
    return s + probs[t]*d*d;
  }, 0);
}

/* =========================================================
   7) コア：価値(V)とスキル(S)を分離してタイプスコア化
   ========================================================= */
function expectedValByPos(pos){ // 1,2,5,6 が価値
  return (pos===1 || pos===2 || pos===5 || pos===6) ? +1 : -1;
}
function dimToSkill(dim){ // 1..4 -> [-1..+1]
  return ({1:-1.0, 2:-0.3, 3:+0.3, 4:+1.0}[dim] ?? 0);
}
function simSq(a,b){
  const d = a-b;
  return -(d*d);
}

function computeScoresFromState(){
  const wV = 3.0;
  const wS = 2.0;
  const wB = 0.55;

  const V = {};
  const S = {};
  for(const e of ELEMENTS){
    const st = state.stats[e];
    V[e] = (st.vN>0) ? (st.vSum / (2*st.vN)) : 0; // -1..+1
    S[e] = (st.dN>0) ? (st.dSum / (2*st.dN)) : 0; // -1..+1
  }

  const scores = Object.fromEntries(TYPES_UI.map(t=>[t, 0]));

  for(const t of TYPES_UI){
    let sc = 0;
    for(const e of ELEMENTS){
      const pos0 = MODEL[t].indexOf(e);
      const pos  = pos0 + 1;

      const expV = expectedValByPos(pos);
      const dim  = parseInt(DIM_BY_POS[pos0],10);
      const expS = dimToSkill(dim);

      sc += wV * simSq(V[e], expV);
      sc += wS * simSq(S[e], expS);
    }
    scores[t] = sc;
  }

  // b補助は answers から再計算（戻る対応）
  for(let i=0;i<state.step;i++){
    const a = state.answers[i];
    if(!a || a.value===null) continue;
    const q = BANK[a.id];
    if(q.kind !== "b") continue;

    const v = a.value;
    for(const t of TYPES_UI){
      const w = (q.wMap && (q.wMap[t] ?? 0)) || 0;
      scores[t] += wB * v * w * q.dir;
    }
  }

  state.scores = scores;
}

/* =========================================================
   8) 回答反映・復元
   ========================================================= */
function applyAnswer(bankId, value){
  const q = BANK[bankId];
  if(value===null) return;

  if(q.element){
    state.elemCount[q.element] = (state.elemCount[q.element] || 0) + 1;
  }

  if(q.kind === "b") return;

  const e = q.element;
  if(!e) return;

  if(q.kind === "v"){
    state.stats[e].vSum += value * q.dir;
    state.stats[e].vN   += 1;
  }else if(q.kind === "d"){
    state.stats[e].dSum += value * q.dir;
    state.stats[e].dN   += 1;
  }
}

function rebuildFromAnswers(){
  state.stats = Object.fromEntries(ELEMENTS.map(e => [e, {vSum:0, vN:0, dSum:0, dN:0}]));
  state.elemCount = Object.fromEntries(ELEMENTS.map(e => [e, 0]));

  for(let i=0;i<state.step;i++){
    const a = state.answers[i];
    if(!a) continue;
    applyAnswer(a.id, a.value);
  }
  computeScoresFromState();
}

/* =========================================================
   9) 適応出題
   ========================================================= */
function pickNextQuestion(){
  computeScoresFromState();
  const probs = softmaxWithTemp(state.scores, 2.6);

  const used = new Set(state.askedIds);
  let best = null;
  let bestScore = -1e9;

  for(let i=0;i<BANK.length;i++){
    if(used.has(i)) continue;
    const q = BANK[i];

    const wByType = Object.fromEntries(TYPES_UI.map(t=>[t, weightForQuestion(t,q)]));
    const discr = varianceWeighted(wByType, probs);

    let penalty = 0;
    if(q.element){
      const c = state.elemCount[q.element] || 0;
      penalty += c * 0.08;
    }
    if(q.kind==="b" && state.step < 18) penalty += 0.25;

    const score = discr - penalty;
    if(score > bestScore){
      bestScore = score;
      best = {id:i, q};
    }
  }
  return best;
}

function ensureNextQuestion(){
  if(state.step >= TARGET_Q) return;
  if(state.askedIds.length > state.step) return;
  const pick = pickNextQuestion();
  state.askedIds.push(pick.id);
}

/* =========================================================
   10) UI
   ========================================================= */
const elBarFill = document.getElementById("barFill");
const elProg = document.getElementById("progText");
const elQNo = document.getElementById("qNo");
const elQText = document.getElementById("qText");
const elScale = document.getElementById("scale");

const btnBack = document.getElementById("btnBack");
const btnSkip = document.getElementById("btnSkip");
const btnNext = document.getElementById("btnNext");

const screenQuiz = document.getElementById("screenQuiz");
const screenResult = document.getElementById("screenResult");

function renderScale(selectedValue){
  elScale.innerHTML = "";
  SCALE.forEach(s=>{
    const d = document.createElement("div");
    d.className = "opt" + (selectedValue===s.v ? " sel" : "");
    d.innerHTML = `<span class="dot"></span><span class="lab">${s.label}</span><span class="sub">${s.v>0?("+"+s.v):(""+s.v)}</span>`;
    d.addEventListener("click", ()=>{
      document.querySelectorAll(".opt").forEach(x=>x.classList.remove("sel"));
      d.classList.add("sel");
      state._pending = s.v;
      btnNext.disabled = false;
    });
    elScale.appendChild(d);
  });
}

function setProgress(){
  elProg.textContent = `${state.step} / ${TARGET_Q}`;
  elBarFill.style.width = `${(state.step/TARGET_Q)*100}%`;
}

function renderCurrent(){
  ensureNextQuestion();
  const bankId = state.askedIds[state.step];
  const q = BANK[bankId];

  elQNo.textContent = `Q${state.step+1}`;
  elQText.textContent = q.text;

  state._pending = null;
  btnNext.disabled = true;

  renderScale(null);
  setProgress();
  btnBack.disabled = (state.step===0);
}

function goNext(withSkip=false){
  const bankId = state.askedIds[state.step];
  const value = withSkip ? null : state._pending;
  if(!withSkip && (value===null || value===undefined)) return;

  // 反映
  applyAnswer(bankId, value);

  // 保存
  state.answers[state.step] = {id: bankId, value};

  // 進む
  state.step += 1;

  if(state.step >= TARGET_Q){
    showResult();
    return;
  }
  renderCurrent();
}

function goBack(){
  if(state.step<=0) return;
  state.step -= 1;
  rebuildFromAnswers();
  renderCurrent();
}

btnNext.addEventListener("click", ()=>goNext(false));
btnSkip.addEventListener("click", ()=>{ state._pending=null; goNext(true); });
btnBack.addEventListener("click", goBack);

document.getElementById("btnRestart").addEventListener("click", ()=>location.reload());

/* =========================================================
   11) 結果画面
   ========================================================= */
function typeSummary(t){
  const q = QUADRA[t];
  const lead = MODEL[t][0], crea = MODEL[t][1];
  const values = [...QUADRA_VALUES[q]].join("・");

  const oneLine = {
    ILE:"発想と構造化で場を前に進めやすい。可能性を広げ、筋道で整理する。",
    SEI:"快適さと空気を整え、自然体の関係を作りやすい。落ち着きと調整が強い。",
    ESE:"雰囲気と生活感を整え、場を温めながら実務も回しやすい。",
    LII:"概念の整理と可能性の扱いが得意。ズレの修正や体系化に強い。",
    EIE:"流れの意味を掴み、感情表現で推進する。熱量や物語で人を動かしやすい。",
    LSI:"規律と意志を基盤に、境界と秩序を守る。ぶれない運用と現実統制。",
    SLE:"状況を見て決めて動く。主導権を取り、現実を切り開く実行が強い。",
    IEI:"流れと空気を読み、適切なタイミングを作る。雰囲気の洞察と共鳴。",
    SEE:"関係と主導で現実を動かす。交渉・推進・突破のセンスが強い。",
    ILI:"流れを読み、実務を選別する。先読みと現実処理のバランス。",
    LIE:"目的へ最短で進む設計が得意。流れを読みつつ成果へ落とす。",
    ESI:"誠実さと境界を守り、関係を整える。筋と責任を重視する。",
    LSE:"実務の段取りと環境調整で安定推進。堅実に回し続ける強さ。",
    EII:"関係の質と可能性を大事にする。誠実さと成長の視点が強い。",
    IEE:"可能性と関係で新展開を作る。人とアイデアの接続が得意。",
    SLI:"快適さと実務で無理なく最適化。静かに改善し続ける職人肌。"
  }[t] || "要点を抽出して表示します。";

  return {quadra:q, lead, crea, values, oneLine};
}

function showResult(){
  computeScoresFromState();
  const probs = softmaxWithTemp(state.scores, 2.6);
  const top3raw = topN(probs, 3);
  const top3disp = formatTop3ForDisplay(top3raw);

  screenQuiz.style.display="none";
  screenResult.style.display="block";

  const head = top3disp.map(([t,p],i)=>`${i+1}位 ${t}（${p}%）`).join(" / ");
  document.getElementById("resHeadline").textContent = head;

  const resCards = document.getElementById("resCards");
  resCards.innerHTML = "";

  top3disp.forEach(([t,p], idx)=>{
    const s = typeSummary(t);
    const div = document.createElement("div");
    div.className = "qbox";
    div.innerHTML = `
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
        <div>
          <div class="small">${idx+1}位</div>
          <div style="font-size:18px;font-weight:900">${t}
            <span style="font-size:11px;color:#334155;border:1px solid var(--line);background:var(--panel);border-radius:999px;padding:4px 8px">
              ${QSYM[s.quadra]} ${s.quadra}
            </span>
          </div>
        </div>
        <div style="font-weight:900">${p}%</div>
      </div>
      <div class="note" style="margin-top:8px">
        主導：<b>${s.lead}</b> ／ 創造：<b>${s.crea}</b><br/>
        価値：${s.values}
      </div>
      <div style="margin-top:10px;line-height:1.8">${s.oneLine}</div>
    `;
    resCards.appendChild(div);
  });
}

/* 初期化 */
renderCurrent();
</script>
</body>
</html>
