<!DOCTYPE html>
<html lang="ja">
<head>
   <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />

  <!-- OGP -->
  <meta property="og:title" content="Socionics 簡易診断">
  <meta property="og:description" content="質問に答えるだけでソシオニクスタイプを推定します。">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://utage-jpg.github.io/typing/">
  <meta property="og:image" content="https://utage-jpg.github.io/typing/topimage_20260116.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

  <!-- X（旧Twitter）用 -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Socionics 簡易診断">
  <meta name="twitter:description" content="質問に答えるだけでソシオニクスタイプを推定します。">
  <meta name="twitter:image" content="https://utage-jpg.github.io/typing/topimage_20260116.png">

  <title>Socionics Typing v2.1.1</title>
  <meta name="theme-color" content="#ff4fd8" />
<style>
:root{
  --bg1:#fff7fb;
  --bg2:#f3f7ff;
  --panel:#ffffff;
  --ink:#0b1220;
  --muted:#51627d;
  --line:rgba(10,20,40,.12);

  --hi:#ff4fd8;
  --hi2:#39b8ff;

  --shadow:0 18px 60px rgba(16,24,40,.14);
  --shadow2:0 8px 24px rgba(16,24,40,.10);
  --glow:0 0 0 5px rgba(255,79,216,.16), 0 0 0 10px rgba(57,184,255,.10);
}
*{box-sizing:border-box}
html,body{
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Hiragino Sans","Noto Sans JP","Yu Gothic",Meiryo,sans-serif;
  background:
    radial-gradient(900px 600px at 10% 10%, rgba(255,79,216,.14), transparent 60%),
    radial-gradient(820px 560px at 90% 0%, rgba(57,184,255,.14), transparent 55%),
    radial-gradient(900px 650px at 50% 105%, rgba(34,197,94,.10), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg2));
  color:var(--ink);
  letter-spacing:.01em;
}
.wrap{max-width:1180px;margin:0 auto;padding:14px;display:grid;gap:12px}

.topbar{
  display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
  padding:14px 16px;border:1px solid var(--line);border-radius:18px;
  background:rgba(255,255,255,.85);backdrop-filter: blur(10px);
  box-shadow:var(--shadow);
}
.brand{display:flex;align-items:center;gap:10px}
.logo{
  width:36px;height:36px;border-radius:14px;
  background:linear-gradient(135deg,var(--hi),var(--hi2));
  box-shadow:0 14px 30px rgba(255,79,216,.18);
}
.brand h1{margin:0;font-size:14px;font-weight:1000;letter-spacing:.08em}
.actions{display:flex;gap:8px;flex-wrap:wrap}

.btn{
  padding:10px 12px;border:1px solid var(--line);border-radius:14px;
  background:rgba(255,255,255,.9);color:var(--ink);
  font-weight:1000;cursor:pointer;min-height:42px;user-select:none;
  box-shadow:var(--shadow2);
}
.btn.primary{
  border-color:transparent;
  background:linear-gradient(135deg,var(--hi),var(--hi2));
  color:#fff;
  box-shadow:0 14px 30px rgba(57,184,255,.18);
}
.btn:active{transform:scale(.99)}
.btn[disabled]{opacity:.45;cursor:not-allowed}

.grid{display:grid;gap:12px}
@media(min-width:940px){
  .grid{grid-template-columns: 1.25fr .75fr;}
}

.card{
  border:1px solid var(--line);
  border-radius:18px;
  background:rgba(255,255,255,.85);
  backdrop-filter: blur(10px);
  box-shadow:var(--shadow);
  overflow:hidden;
}
.body{padding:16px;display:grid;gap:12px}

.row{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.bar{
  flex:1;min-width:220px;height:12px;border-radius:999px;overflow:hidden;
  border:1px solid var(--line);background:rgba(10,20,40,.06)
}
.bar>div{height:100%;width:0%;background:linear-gradient(90deg,var(--hi),var(--hi2))}
.badge{
  display:inline-flex;align-items:center;gap:8px;
  padding:8px 12px;border-radius:999px;border:1px solid var(--line);
  background:rgba(255,255,255,.9);font-size:12px;color:var(--ink);font-weight:1000;
  box-shadow:var(--shadow2);
}

.qbox{
  border:1px solid var(--line);
  border-radius:16px;
  padding:16px;
  background:rgba(255,255,255,.9);
  box-shadow:var(--shadow2);
}
.qno{font-weight:1200;font-size:12px;color:var(--muted);letter-spacing:.12em}
.qtext{font-size:16px;line-height:1.85;margin:10px 0 14px}

.scale5,.scale3{display:grid;gap:10px}
@media(min-width:740px){ .scale5{grid-template-columns:repeat(5,1fr)} .scale3{grid-template-columns:repeat(3,1fr)} }

.opt{
  border:1px solid var(--line); border-radius:16px; padding:12px;
  background:rgba(255,255,255,.95); cursor:pointer; user-select:none;
  display:flex; align-items:center; gap:10px; min-height:56px;
  transition:.12s;
  box-shadow:0 10px 18px rgba(16,24,40,.06);
}
.opt:hover{transform:translateY(-1px);box-shadow:var(--glow)}
.dot{
  width:16px;height:16px;border-radius:999px;border:2px solid rgba(10,20,40,.25);
  display:inline-block;position:relative;flex:0 0 auto
}
.opt.sel{
  border-color:rgba(255,79,216,.55);
  box-shadow:var(--glow);
}
.opt.sel .dot{border-color:var(--hi)}
.opt.sel .dot::after{
  content:"";position:absolute;inset:3px;border-radius:999px;background:var(--hi)
}
.lab{font-size:13px;color:var(--ink);font-weight:1100}
.subv{font-size:11px;color:var(--muted);margin-left:auto;font-weight:1100}

.controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}

.kv{
  border:1px solid var(--line);
  border-radius:16px;
  background:rgba(255,255,255,.9);
  padding:12px;
  box-shadow:var(--shadow2);
}
.kv .t{font-size:12px;color:var(--muted);letter-spacing:.10em}

.rankItem{
  display:flex;align-items:center;justify-content:space-between;gap:10px;
  padding:10px 12px;border-radius:16px;border:1px solid var(--line);
  background:rgba(255,255,255,.95);
  box-shadow:0 10px 18px rgba(16,24,40,.06);
}
.rankItem b{font-weight:1200}
.pct{font-weight:1200}
.barMini{
  width:120px;height:9px;border-radius:999px;overflow:hidden;border:1px solid var(--line);
  background:rgba(10,20,40,.06);display:inline-block;vertical-align:middle;margin-left:10px
}
.barMini>span{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--hi),var(--hi2))}
.hr{height:1px;background:var(--line);margin:8px 0}
.small{font-size:12px;color:var(--muted);line-height:1.7}
.hidden{display:none !important;}
.pill{
  display:inline-flex;align-items:center;gap:8px;
  border:1px solid var(--line);
  background:rgba(10,20,40,.04);
  padding:6px 10px;border-radius:999px;
  font-size:12px;color:var(--ink);font-weight:1100;
}
</style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>Socionics Typing v2.1.1</h1>
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="btnToggleLive">上位候補を表示</button>
      <button class="btn" id="btnRestartTop">最初から</button>
    </div>
  </div>

  <div class="grid">
    <!-- MAIN -->
    <div class="card">
      <div class="body" id="screenQuiz">
        <div class="row">
          <div class="bar" aria-label="progress"><div id="barFill"></div></div>
          <div class="badge"><b id="progText">0 / 60</b></div>
        </div>

        <div class="qbox">
          <div class="qno" id="qNo">Q1</div>
          <div class="qtext" id="qText">—</div>

          <div class="scale5" id="scale5"></div>
          <div class="scale3" id="scale3" style="display:none"></div>

          <div class="controls" style="margin-top:12px">
            <button class="btn" id="btnBack" disabled>戻る</button>
            <button class="btn" id="btnSkip">わからない</button>
            <button class="btn primary" id="btnNext" disabled>次へ</button>
          </div>
        </div>
      </div>

      <div class="body" id="screenResult" style="display:none">
        <div class="qbox">
          <div class="small">結果（上位3タイプ）</div>
          <div style="font-size:18px;font-weight:1200;margin-top:6px" id="resHeadline">—</div>
          <div class="hr"></div>
          <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end">
            <button class="btn primary" id="btnRestart">最初から</button>
          </div>
        </div>

        <div id="resCards" style="display:grid;gap:12px;margin-top:12px"></div>

        <!-- Feedback -->
        <div class="qbox" id="feedbackBox">
          <div class="row">
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
              <span class="pill">フィードバック</span>
              <span class="small">（1位タイプを前提に、回答傾向を要点化します）</span>
            </div>
            <button class="btn" id="btnToggleFeedback">開く</button>
          </div>
          <div class="hr"></div>
          <div id="feedbackContent" class="hidden">
            <div class="small" id="fbQuadra">—</div>
            <div style="display:grid;gap:10px;margin-top:10px">
              <div>
                <div style="font-weight:1200;margin-bottom:6px">価値（優先しやすい情報要素）</div>
                <div class="small" id="fbValues">—</div>
              </div>
              <div>
                <div style="font-weight:1200;margin-bottom:6px">回答から見えた強まり</div>
                <div class="small" id="fbStrong">—</div>
              </div>
              <div>
                <div style="font-weight:1200;margin-bottom:6px">1位タイプらしさとズレやすい点（要注意ポイント）</div>
                <div class="small" id="fbMismatch">—</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- SIDE (hidden by default; becomes persistent when toggled) -->
    <div class="card hidden" id="sideCard">
      <div class="body">
        <div class="kv">
          <div class="t">上位候補</div>
          <div id="topList" style="display:grid;gap:10px;margin-top:10px"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   1) タイプ・Model A
   ========================================================= */
const TYPES=["ILE","SEI","ESE","LII","EIE","LSI","SLE","IEI","SEE","ILI","LIE","ESI","LSE","EII","IEE","SLI"];
const ELEMENTS=["Te","Ti","Fe","Fi","Ne","Ni","Se","Si"];

const QUADRA={
  ILE:"Alpha", SEI:"Alpha", ESE:"Alpha", LII:"Alpha",
  EIE:"Beta",  LSI:"Beta",  SLE:"Beta",  IEI:"Beta",
  SEE:"Gamma", ILI:"Gamma", LIE:"Gamma", ESI:"Gamma",
  IEE:"Delta", SLI:"Delta", LSE:"Delta", EII:"Delta"
};
const QSYM={Alpha:"α",Beta:"β",Gamma:"γ",Delta:"Δ"};

const MODEL={
  ILE:["Ne","Ti","Se","Fi","Si","Fe","Ni","Te"],
  SEI:["Si","Fe","Ni","Te","Ne","Ti","Se","Fi"],
  ESE:["Fe","Si","Te","Ni","Ti","Ne","Fi","Se"],
  LII:["Ti","Ne","Fi","Se","Fe","Si","Te","Ni"],
  EIE:["Fe","Ni","Te","Si","Ti","Se","Fi","Ne"],
  SLE:["Se","Ti","Ne","Fi","Ni","Fe","Si","Te"],
  LSI:["Ti","Se","Fi","Ne","Fe","Ni","Te","Si"],
  IEI:["Ni","Fe","Si","Te","Se","Ti","Ne","Fi"],
  SEE:["Se","Fi","Ne","Ti","Ni","Te","Si","Fe"],
  ILI:["Ni","Te","Si","Fe","Se","Fi","Ne","Ti"],
  LIE:["Te","Ni","Fe","Si","Fi","Se","Ti","Ne"],
  ESI:["Fi","Se","Ti","Ne","Te","Ni","Fe","Si"],
  SLI:["Si","Te","Ni","Fe","Ne","Fi","Se","Ti"],
  IEE:["Ne","Fi","Se","Ti","Si","Te","Ni","Fe"],
  LSE:["Te","Si","Fe","Ni","Fi","Ne","Ti","Se"],
  EII:["Fi","Ne","Ti","Se","Te","Si","Fe","Ni"]
};
const DIM_BY_POS=["4","3","2","1","1","2","3","4"];
const QUADRA_VALUES={
  Alpha:new Set(["Ne","Ti","Fe","Si"]),
  Beta :new Set(["Fe","Ni","Se","Ti"]),
  Gamma:new Set(["Fi","Te","Se","Ni"]),
  Delta:new Set(["Si","Te","Fi","Ne"])
};
function elementPos(t,e){ return MODEL[t].indexOf(e); }
function elementDim(t,e){
  const p = elementPos(t,e);
  if(p<0) return 2;
  return parseInt(DIM_BY_POS[p],10);
}
function isValued(t,e){ return QUADRA_VALUES[QUADRA[t]].has(e); }
function isSuggestive(t,e){ return elementPos(t,e)===4; } // 5th
function isMobilizing(t,e){ return elementPos(t,e)===5; } // 6th

/* =========================================================
   2) GRM / Choice
   ========================================================= */
function sigmoid(x){ return 1/(1+Math.exp(-x)); }
function grmCategoryProbs(theta, a, bs){
  const Pge=[1];
  for(let k=0;k<4;k++) Pge.push(sigmoid(a*(theta-bs[k])));
  Pge.push(0);
  const P=[];
  for(let k=0;k<5;k++) P.push(Math.max(1e-12, Pge[k]-Pge[k+1]));
  const s=P.reduce((x,y)=>x+y,0);
  return P.map(x=>x/s);
}
function choiceProbs(theta, a){
  const pA=sigmoid(a*theta);
  const neutral=0.22+0.28*Math.exp(-Math.abs(theta)*1.4);
  const rest=Math.max(1e-9,1-neutral);
  const A=rest*pA, B=rest*(1-pA);
  const s=A+B+neutral;
  return {A:A/s,N:neutral/s,B:B/s};
}

/* =========================================================
   3) BANK
   ========================================================= */
const BANK=[];
function defaultParams(kind){
  if(kind==="v") return {a:1.55, bs:[-1.2,-0.3,0.4,1.2]};
  if(kind==="d") return {a:1.25, bs:[-1.3,-0.4,0.4,1.3]};
  if(kind==="b") return {a:1.05, bs:[-1.1,-0.25,0.25,1.1]};
  if(kind==="s") return {a:1.35, bs:[-1.25,-0.35,0.45,1.25]}; // suggestive
  if(kind==="m") return {a:1.35, bs:[-1.25,-0.35,0.45,1.25]}; // mobilizing
  return {a:1.20, bs:[-1.2,-0.3,0.4,1.2]};
}
function addV(e,text,dir=+1){ const p=defaultParams("v"); BANK.push({kind:"v",element:e,dir,text,a:p.a,bs:p.bs});}
function addD(e,text,dir=+1){ const p=defaultParams("d"); BANK.push({kind:"d",element:e,dir,text,a:p.a,bs:p.bs});}
function addB(text,wMap,dir=+1){ const p=defaultParams("b"); BANK.push({kind:"b",element:null,dir,text,wMap,a:p.a,bs:p.bs});}
function addC(pair,mapAB,a=1.75){ BANK.push({kind:"c",element:null,pair,mapAB,a});}
function addS(e,text,dir=+1){ const p=defaultParams("s"); BANK.push({kind:"s",element:e,dir,text,a:p.a,bs:p.bs});}
function addM(e,text,dir=+1){ const p=defaultParams("m"); BANK.push({kind:"m",element:e,dir,text,a:p.a,bs:p.bs});}

/* --- 質問テキスト（v/d/b/c） --- */
const V_POS={
  Ne:["話が一つに固まると、別の切り口や例を足したくなります。","未経験でも「やってみたら面白そう」が先に立ちます。","選べる余地があるほど発想が出やすいです。","会話で相手の話を聞くほど、別の可能性が思い浮かびます。","アイデア出しの場では、まず数を増やす方が得意です。","規定路線より、例外や別案の方が気になります。"],
  Ni:["目の前の出来事から、少し先の展開を自然に想像してしまいます。","判断するとき、タイミングや流れを重視します。","急いで決めるより、一度寝かせて全体像を見たいです。","出来事の背景にある“流れ”をつい考えてしまいます。","短期の雑音より、長期の方向性に意識が向きます。","言語化できなくても「今じゃない」と感じることがあります。"],
  Se:["迷っている場面では、まず決めて動く方が良いと思います。","必要なら、少し強めに言ってでも前に進めたいです。","交渉や勝負どころでは、主導権が重要だと感じます。","迷いがある状況でも、決断して前に進められます。","境界線（ここまでOK/NG）をはっきりさせたいです。","状況を動かすために前に出る役ができます。"],
  Si:["効率より先に、無理なく続けられる状態を整えたいです。","小さな不快があると、集中や気分が落ちやすいです。","予定を詰めすぎないよう、前もって調整したくなります。","ペース配分を作ると、全体が安定すると感じます。","生活や環境を整えると、精神も落ち着きます。","長く続く運用にするには、微調整が大事だと思います。"],
  Ti:["言葉の意味がズレていると、まずそこを揃えたくなります。","「なんとなく」より「筋が通るか」を重視して判断します。","説明は、前提→論点→結論の形に整えたくなります。","分類や定義づけで複雑な話を整理できます。","矛盾に気づくと放置できません。","枠組みがあると議論が進むと思います。"],
  Te:["話が抽象的だと、数字・期限・手順に落として考えたくなります。","複数案があるなら、最短で成果が出る方法を探します。","評判より、実績や比較データを重視します。","情報を集めるとき、要点だけ抜いて意思決定に使えます。","成果につながらない作業は早めに切り替えたいです。","具体的な段取りに落とせると安心します。"],
  Fe:["場が静かすぎると、少しでも空気を動かしたくなります。","相手のテンションに合わせて、声色やリアクションが変わります。","正しさより、場がうまく回るかを優先することがあります。","雰囲気を変えたいとき、自然にスイッチを入れられます。","感情を言葉にして共有すると連携しやすいです。","場の温度が下がると、上げたくなります。"],
  Fi:["人を見るとき、能力より誠実さや信頼を重視します。","距離感が近すぎ/遠すぎる違和感に気づきやすいです。","立場が違っても、約束や筋は守るべきだと思います。","信頼を損ねずにNOを言う（断る）ことができます。","関係性を考えて言い方を選びます。","相手の境界線を尊重したいです。"]
};
const V_NEG={
  Ne:["アイデアを増やすより、早く一つに決めて進めたいです。","可能性の話より、「今すぐできること」を詰めたいです。","予定が決まっていない相談は苦手です。","別案を出すより、結論まで一直線に進めたいです。","余白があると落ち着かず、決めたくなります。","例外より標準手順が安心です。"],
  Ni:["先のことを考えすぎるより、今すぐ手を動かしたいです。","流れより、手順やチェックリストがある方が安心します。","長期の話が続くと、今の現実の話に戻したくなります。","雰囲気や兆しより、根拠がないと判断しません。","タイミングより、今日できることを優先します。","先読みを求められると苦手です。"],
  Se:["強く出るより、揉めない形で合意を作りたいです。","押し切るより、相手が自然に納得するのを待ちたいです。","勝つ/負けるの空気が濃い場は疲れます。","緊張感がある場面では一歩引いて様子を見ます。","主導を取るより、調整役が楽です。","対立を避けたいです。"],
  Si:["快適さより、多少きつくても短期で達成したいです。","体調や環境より、スピードを優先しがちです。","細かい調整は苦手で、まとめて片付けたいです。","居心地より、刺激や変化がある方が楽しいです。","ペースより勢いで進めたいです。","不快でも我慢して進めます。"],
  Ti:["細かい整合性より、勢いで進めたいです。","定義にこだわる議論は面倒に感じます。","筋より、結果が出るかを優先したいです。","枠組みより、その場で最適に対応したいです。","分類は後回しで、とにかく動きたいです。","矛盾は気にしない方です。"],
  Te:["効率より、納得感や関係性を優先したいです。","数字やKPIの話が続くと空気が乾く感じがします。","成果だけでなく、過程の意味を重視したいです。","結論より先に、まず話して温度感を合わせたいです。","比較より直感で選びたいです。","段取りを詰めるより気分で動きます。"],
  Fe:["感情表現が多い場は情報が多くて疲れます。","ノリより、淡々と本題を進めたいです。","気持ちは言葉より、行動で示す方が楽です。","盛り上げ役を期待されると負担です。","感情の共有は必要最低限でいいです。","リアクションを求められると困ります。"],
  Fi:["関係性より、役割や成果で割り切る方が楽です。","気持ちを読むより、事実と条件を揃えたいです。","距離感を考えるのは得意ではありません。","少しドライでも、目的が達成できれば問題ないです。","信頼より合理性を優先します。","個人的な感情は切り離したいです。"]
};

const D_POS={
  Te:["慣れない分野でも、比較表や手順化で“使える形”に落とせます。","急に成果や数字を求められても、現実的な案を出せます。","情報を集めるとき、要点だけ抜いて意思決定に使えます。","タスクの優先順位を状況に合わせて組み替えられます。"],
  Ti:["複雑な話でも、前提と論点を整理して矛盾を見つけられます。","分類や定義づけで説明をシンプルにできます。","議論が迷走したとき、枠組みを作って立て直せます。","用語や前提のズレを検知して揃えられます。"],
  Fe:["空気が荒れていても、温度を読んで落とし所を作れます。","相手の反応を見ながら、言い方やテンポを調整できます。","場の雰囲気を変えたいとき、自然にスイッチを入れられます。","ギクシャクした場の緊張を和らげられます。"],
  Fi:["関係がこじれた時、境界線を保ちつつ修復の方針を作れます。","相手の立場が変わっても、距離感をうまく調整できます。","信頼を損ねずにNOを言う（断る）ことができます。","大事な約束や誠実さを長期で守れます。"],
  Ne:["行き詰まりのとき、別解や例外パターンを複数出せます。","未知でも仮説を置いて探索を進められます。","会話が詰まったとき、話題の枝を増やして広げられます。","新しい組み合わせの提案ができます。"],
  Ni:["兆しから先回りして準備や方向転換ができます。","短期の雑音に惑わされず、流れの主題を掴めます。","優先順位を“いまのタイミング”で調整できます。","リスクが顕在化する前に手を打てます。"],
  Se:["抵抗があっても、必要なら押し切る実行ができます。","対立場面でも、自分の立場を保って交渉できます。","迷いがある状況でも、決断して前に進められます。","プレッシャー下でも行動が止まりにくいです。"],
  Si:["忙しくても、負担が破綻しないよう微調整できます。","居心地の差を言語化して改善提案できます。","ペースを整え、長く続く運用にできます。","疲労が溜まる前に回復/調整できます。"]
};
const D_NEG={
  Te:["実務の話になると、経験がないと途端に自信がなくなります。","段取りを詰めるのが苦手です。"],
  Ti:["論理の突っ込みが来ると、頭が真っ白になりやすいです。","言葉の定義に自信が持てません。"],
  Fe:["感情のやり取りが続くと、どうしていいかわからなくなります。","場の空気を読むのが負担です。"],
  Fi:["人間関係の揉め事は、なるべく見ないふりをしたくなります。","距離感の調整が苦手です。"],
  Ne:["選択肢が増えると、かえって動けなくなります。","未知の領域は避けがちです。"],
  Ni:["先読みを求められると、不安になって避けたくなります。","流れを読むのが苦手です。"],
  Se:["強く出る必要があると、萎縮してしまいます。","対立が怖いです。"],
  Si:["体調や快適さの調整を後回しにして、限界まで走りがちです。","微調整が苦手です。"]
};

function wMapFromYes(yesTypes){
  return Object.fromEntries(TYPES.map(t=>[t, yesTypes.includes(t)? +1 : -1]));
}
const B_ITEMS=[
  {text:"人が多い場の後、元気が増えるというより“消耗して静かな時間が欲しくなる”ことが多いです。", wMap:wMapFromYes(["ILI","IEI","LII","EII","SLI","SEI","ILE","IEE"])},
  {text:"新しい人間関係に飛び込むより、既にある関係を深める方が落ち着きます。", wMap:wMapFromYes(["EII","ESI","LSI","LII","SLI","ILI","SEI","IEI"])},
  {text:"予定や段取りが固まってから動く方が安心です。", wMap:wMapFromYes(["LSE","LIE","ESE","EIE","LSI","LII","ESI","EII"])},
  {text:"細かい計画より、状況を見ながら柔軟に変える方が得意です。", wMap:wMapFromYes(["ILE","IEE","SEI","SLI","SLE","SEE","IEI","ILI"])},
  {text:"議論の場で、感情の納得より“筋が通っているか”を優先しがちです。", wMap:wMapFromYes(["LII","LSI","ILE","SLE","LSE","LIE","ILI","SLI"])},
  {text:"正しさより、相手がどう感じるか（関係がどうなるか）を優先しがちです。", wMap:wMapFromYes(["EII","ESI","IEE","SEE","ESE","EIE","SEI","IEI"])},
  {text:"議論は重くしすぎず、アイデアや冗談で軽快に回る方が好きです。", wMap:wMapFromYes(["ILE","SEI","ESE","LII"])},
  {text:"集団で熱量を揃え、勢いを作って突破する空気にワクワクします。", wMap:wMapFromYes(["EIE","LSI","SLE","IEI"])},
  {text:"目的と責任範囲が明確で、実利のある話が一番落ち着きます。", wMap:wMapFromYes(["SEE","ILI","LIE","ESI"])},
  {text:"大きなドラマより、生活や環境を整えながらじわっと良くするのが好きです。", wMap:wMapFromYes(["SLI","IEE","LSE","EII"])}
];

function mapByElements(favorA,favorB){
  const setA=new Set(favorA), setB=new Set(favorB);
  return (t)=>{
    const lead=MODEL[t][0], crea=MODEL[t][1];
    let s=0;
    if(setA.has(lead)) s+=0.8;
    if(setA.has(crea)) s+=0.45;
    if(setB.has(lead)) s-=0.8;
    if(setB.has(crea)) s-=0.45;
    for(const e of QUADRA_VALUES[QUADRA[t]]){
      if(setA.has(e)) s+=0.08;
      if(setB.has(e)) s-=0.08;
    }
    return Math.max(-1, Math.min(1, s));
  };
}
const C_ITEMS=[
  {pair:{A:"（A）アイデアを増やしてから決めたい",B:"（B）早めに一つに決めて進めたい"}, map:mapByElements(["Ne"],["Te","Se","Ti"])},
  {pair:{A:"（A）場の空気や気持ちを整えたい",B:"（B）結論と手順を優先したい"}, map:mapByElements(["Fe","Fi"],["Te","Ti"])},
  {pair:{A:"（A）流れやタイミングを見て動きたい",B:"（B）今すぐ実行して前に進めたい"}, map:mapByElements(["Ni"],["Se","Te"])},
  {pair:{A:"（A）揉めない合意を作りたい",B:"（B）必要なら押し切ってでも進めたい"}, map:mapByElements(["Fi","Fe"],["Se"])},
  {pair:{A:"（A）快適さやペースを守って続けたい",B:"（B）多少きつくても短期で達成したい"}, map:mapByElements(["Si"],["Te","Se"])},
  {pair:{A:"（A）定義や構造を揃えてから進めたい",B:"（B）現場で回しながら最適化したい"}, map:mapByElements(["Ti"],["Te","Se"])},
  {pair:{A:"（A）関係の質（信頼）を最優先したい",B:"（B）成果（実利）を最優先したい"}, map:mapByElements(["Fi"],["Te"])},
  {pair:{A:"（A）人の感情を言葉にして共有したい",B:"（B）感情より事実だけ共有したい"}, map:mapByElements(["Fe"],["Te","Ti"])},
  {pair:{A:"（A）変化や刺激がある方が楽しい",B:"（B）安定して整っている方が楽しい"}, map:mapByElements(["Ne","Se"],["Si"])},
  {pair:{A:"（A）“先の意味/方向”を掴みたい",B:"（B）“今の手順/実行”を掴みたい"}, map:mapByElements(["Ni"],["Te","Se"])},
];

/* ★暗示/動員 */
const S_TEMPLATE = (e)=>`（暗示）「${e}」は自分では弱いですが、得意な人にサポートされるとすごく助かります。`;
const M_TEMPLATE = (e)=>`（動員）「${e}」は得意ではないのに、なぜか「頑張ればできる」と思って背伸びしてしまいます。`;

function buildBank(){
  BANK.length=0;
  for(const e of ELEMENTS){
    (V_POS[e]||[]).forEach((t)=>addV(e,t,+1));
    (V_NEG[e]||[]).forEach((t)=>addV(e,t,-1));
  }
  for(const e of ELEMENTS){
    (D_POS[e]||[]).forEach((t)=>addD(e,t,+1));
    (D_NEG[e]||[]).forEach((t)=>addD(e,t,-1));
  }
  for(const b of B_ITEMS) addB(b.text, b.wMap, +1);
  for(const c of C_ITEMS) addC(c.pair, c.map, 1.75);
  for(const e of ELEMENTS){
    addS(e, S_TEMPLATE(e), +1);
    addM(e, M_TEMPLATE(e), +1);
  }
}
buildBank();

/* =========================================================
   4) UIスケール
   ========================================================= */
const SCALE5=[
  {label:"そう思う", v:+2, c:0},
  {label:"部分的にそう思う", v:+1, c:1},
  {label:"中立", v:0, c:2},
  {label:"あまりそう思わない", v:-1, c:3},
  {label:"全くそう思わない", v:-2, c:4},
];
const SCALE3=[
  {label:"Aに近い", v:+1, k:"A"},
  {label:"どちらでもない", v:0, k:"N"},
  {label:"Bに近い", v:-1, k:"B"},
];

/* =========================================================
   5) 状態
   ========================================================= */
const MIN_Q=40, TARGET_Q=60, MAX_Q=80;

const state={
  step:0,
  asked:[],
  answers:[],
  posterior:Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length])),
  pending:null, pendingKind:null,

  respStats:{n:0, mean:0, m2:0, neutral:0, extreme:0},

  historyTop1:[],
  historyGap:[],
  livePinned:false,
};

function clamp(x,a,b){return Math.max(a,Math.min(b,x));}
function normalize(obj){
  const s=Object.values(obj).reduce((a,b)=>a+b,0)||1;
  const out={}; for(const k in obj) out[k]=obj[k]/s;
  return out;
}
function entropy(probs){
  let h=0;
  for(const p of Object.values(probs)){
    if(p<=0) continue;
    h -= p*Math.log(p);
  }
  return h;
}
function topN(probs,n=4){
  return Object.entries(probs).sort((a,b)=>b[1]-a[1]).slice(0,n);
}
function gapTop2(probs){
  const t=topN(probs,2);
  if(t.length<2) return 1;
  return t[0][1]-t[1][1];
}

/* =========================================================
   6) θ（タイプ×設問）
   ========================================================= */
const dimToTheta={1:-0.95,2:-0.25,3:+0.45,4:+1.05};

function thetaFor(type,q){
  if(q.kind==="v"){
    const exp=isValued(type,q.element)? +1 : -1;
    return 1.05 * exp * q.dir;
  }
  if(q.kind==="d"){
    const dim=elementDim(type,q.element);
    return 1.00 * (dimToTheta[dim]??0) * q.dir;
  }
  if(q.kind==="b"){
    const w=(q.wMap && (q.wMap[type]??0)) || 0;
    return 0.80 * w * q.dir;
  }
  if(q.kind==="c"){
    const s=q.mapAB? q.mapAB(type) : 0;
    return clamp(1.00*s, -1, 1);
  }
  if(q.kind==="s"){
    const e=q.element;
    if(isSuggestive(type,e)) return +0.95 * q.dir;
    if(isMobilizing(type,e)) return +0.25 * q.dir;
    if(elementPos(type,e)===0 || elementPos(type,e)===1) return -0.35 * q.dir;
    return -0.10 * q.dir;
  }
  if(q.kind==="m"){
    const e=q.element;
    if(isMobilizing(type,e)) return +0.95 * q.dir;
    if(isSuggestive(type,e)) return +0.30 * q.dir;
    if(elementPos(type,e)===0 || elementPos(type,e)===1) return -0.30 * q.dir;
    return -0.08 * q.dir;
  }
  return 0;
}

/* =========================================================
   7) 温度補正（回答癖）
   ========================================================= */
function updateRespStatsLikert(raw){
  const s=state.respStats;
  s.n+=1;
  const delta=raw-s.mean;
  s.mean+=delta/s.n;
  const delta2=raw-s.mean;
  s.m2+=delta*delta2;

  if(raw===0) s.neutral+=1;
  if(Math.abs(raw)===2) s.extreme+=1;
}
function stdev(){
  const s=state.respStats;
  if(s.n<8) return 1.0;
  const v=s.m2/(s.n-1);
  return clamp(Math.sqrt(v), 0.55, 1.55);
}
function temperature(){
  const s=state.respStats;
  const sd=stdev();
  const neutralRate = s.n>0 ? (s.neutral/s.n) : 0;
  const extremeRate = s.n>0 ? (s.extreme/s.n) : 0;

  let T=1.0;
  if(neutralRate>0.48) T+=0.18;
  if(extremeRate>0.62) T+=0.12;
  if(sd<0.78) T+=0.12;
  if(sd>1.22) T+=0.12;
  return clamp(T, 0.85, 1.65);
}
function tempAdjustLike(like){
  const T=temperature();
  return Math.pow(Math.max(1e-12, like), 1.0/T);
}

/* =========================================================
   8) ベイズ更新
   ========================================================= */
function bayesUpdateGRM(posterior,q,catIndex){
  const out={};
  for(const t of TYPES){
    const prior=posterior[t];
    const th=thetaFor(t,q);
    const P=grmCategoryProbs(th,q.a,q.bs);
    const like=tempAdjustLike(P[catIndex]||1e-12);
    out[t]=prior*like;
  }
  return normalize(out);
}
function bayesUpdateChoice(posterior,q,choiceKey){
  const out={};
  for(const t of TYPES){
    const prior=posterior[t];
    const th=thetaFor(t,q);
    const P=choiceProbs(th,q.a);
    const like=tempAdjustLike(P[choiceKey]||1e-12);
    out[t]=prior*like;
  }
  return normalize(out);
}

/* =========================================================
   9) EIG
   ========================================================= */
function restrictToTopK(posterior,K){
  const top=topN(posterior,K);
  const keep=new Set(top.map(x=>x[0]));
  const out={};
  for(const t of TYPES) out[t]=keep.has(t)? posterior[t] : 0;
  return normalize(out);
}
function expectedEntropyAfter(q,posterior){
  const H0=entropy(posterior);

  if(q.kind==="c"){
    const ans=["A","N","B"];
    const Pa={A:0,N:0,B:0};
    for(const t of TYPES){
      const th=thetaFor(t,q);
      const P=choiceProbs(th,q.a);
      Pa.A+=posterior[t]*P.A;
      Pa.N+=posterior[t]*P.N;
      Pa.B+=posterior[t]*P.B;
    }
    const PaN=normalize(Pa);
    let EH=0;
    for(const k of ans){
      const postK=bayesUpdateChoice(posterior,q,k);
      EH+=(PaN[k]||0)*entropy(postK);
    }
    return {EIG:H0-EH,H0};
  }else{
    const Pa=[0,0,0,0,0];
    for(const t of TYPES){
      const th=thetaFor(t,q);
      const P=grmCategoryProbs(th,q.a,q.bs);
      for(let k=0;k<5;k++) Pa[k]+=posterior[t]*P[k];
    }
    const sum=Pa.reduce((a,b)=>a+b,0)||1;
    const Pn=Pa.map(x=>x/sum);

    let EH=0;
    for(let k=0;k<5;k++){
      const postK=bayesUpdateGRM(posterior,q,k);
      EH+=(Pn[k]||0)*entropy(postK);
    }
    return {EIG:H0-EH,H0};
  }
}

function pickNextQuestion(){
  const used=new Set(state.asked);
  const step=state.step;

  const base = (step>=14) ? restrictToTopK(state.posterior, 8) : state.posterior;
  const focus = (step>=34) ? restrictToTopK(state.posterior, 5) : base;

  let bestId=null, bestScore=-1e9;

  const wantChoice = (step>=42);
  const allowChoice = (step>=28);

  for(let i=0;i<BANK.length;i++){
    if(used.has(i)) continue;
    const q=BANK[i];

    if(step<10 && q.kind==="b") continue;
    if(!allowChoice && q.kind==="c") continue;

    let pref=1.0;
    if(wantChoice){
      if(q.kind==="c") pref*=1.20;
      else pref*=0.92;
    }else{
      if(q.kind==="c") pref*=0.86;
    }
    if(step>=20 && (q.kind==="s" || q.kind==="m")) pref*=1.08;
    if(step>=36 && (q.kind==="s" || q.kind==="m")) pref*=1.10;

    let penalty=0;
    if(q.element){
      const cnt=state.answers.slice(0,step).filter(a=>a && !a.skipped && BANK[a.id].element===q.element).length;
      penalty += cnt*0.07;
    }
    if(q.kind==="b") penalty += 0.12;

    const {EIG}=expectedEntropyAfter(q, focus);

    const gap=gapTop2(state.posterior);
    const splitBoost = (step>=16 && gap<0.10 && (q.kind==="c")) ? 1.28 : 1.0;

    const score = pref * splitBoost * EIG - penalty;
    if(score>bestScore){ bestScore=score; bestId=i; }
  }

  if(bestId===null){
    for(let i=0;i<BANK.length;i++){
      if(!used.has(i)){ bestId=i; break; }
    }
  }
  return bestId;
}

/* =========================================================
   10) 動的停止
   ========================================================= */
function stopStatus(){
  const step=state.step;
  const H=entropy(state.posterior);
  const gap=gapTop2(state.posterior);

  const last=state.historyTop1.slice(-6);
  const stable=(last.length>=6)&&last.every(x=>x===last[0]);

  const confident=(H<1.70)&&(gap>0.16)&&stable;

  if(step<MIN_Q) return {canStop:false};
  if(step>=MAX_Q) return {canStop:true};

  if(step>=TARGET_Q){
    const ok = confident || ((H<1.80)&&(gap>0.14)&&stable);
    return {canStop:ok};
  }
  return {canStop:confident};
}

/* =========================================================
   11) UI
   ========================================================= */
const elBarFill=document.getElementById("barFill");
const elProg=document.getElementById("progText");
const elQNo=document.getElementById("qNo");
const elQText=document.getElementById("qText");
const elScale5=document.getElementById("scale5");
const elScale3=document.getElementById("scale3");

const topList=document.getElementById("topList");

const btnBack=document.getElementById("btnBack");
const btnSkip=document.getElementById("btnSkip");
const btnNext=document.getElementById("btnNext");

const screenQuiz=document.getElementById("screenQuiz");
const screenResult=document.getElementById("screenResult");

const sideCard=document.getElementById("sideCard");
const btnToggleLive=document.getElementById("btnToggleLive");

function setProgress(){
  elProg.textContent = `${state.step} / ${TARGET_Q}`;
  elBarFill.style.width = `${clamp(state.step/TARGET_Q,0,1)*100}%`;
}

/* Likert cat 反転（0↔4, 1↔3） */
function renderScale5(){
  elScale5.innerHTML="";
  SCALE5.forEach(s=>{
    const d=document.createElement("div");
    d.className="opt";
    d.innerHTML=`<span class="dot"></span><span class="lab">${s.label}</span><span class="subv">${s.v>0?("+"+s.v):(""+s.v)}</span>`;
    d.addEventListener("click", ()=>{
      document.querySelectorAll("#scale5 .opt").forEach(x=>x.classList.remove("sel"));
      d.classList.add("sel");

      const catFixed = 4 - s.c; // ★GRM方向合わせ
      state.pending = {raw:s.v, cat:catFixed};
      state.pendingKind="likert";
      btnNext.disabled=false;
    });
    elScale5.appendChild(d);
  });
}
function renderScale3(){
  elScale3.innerHTML="";
  SCALE3.forEach(s=>{
    const d=document.createElement("div");
    d.className="opt";
    d.innerHTML=`<span class="dot"></span><span class="lab">${s.label}</span>`;
    d.addEventListener("click", ()=>{
      document.querySelectorAll("#scale3 .opt").forEach(x=>x.classList.remove("sel"));
      d.classList.add("sel");
      state.pending = {key:s.k, v:s.v};
      state.pendingKind="choice";
      btnNext.disabled=false;
    });
    elScale3.appendChild(d);
  });
}

function updateSide(){
  if(!state.livePinned) return;

  const top=topN(state.posterior,4);
  topList.innerHTML="";
  top.forEach(([t,p])=>{
    const div=document.createElement("div");
    div.className="rankItem";
    div.innerHTML=`<b>${t} <span style="opacity:.75;font-weight:1100">(${QSYM[QUADRA[t]]} ${QUADRA[t]})</span></b>
                   <span class="pct">${Math.round(p*100)}% <span class="barMini"><span style="width:${clamp(p,0,1)*100}%"></span></span></span>`;
    topList.appendChild(div);
  });
}

function renderQuestion(){
  if(state.asked.length<=state.step){
    const id=pickNextQuestion();
    state.asked.push(id);
  }
  const id=state.asked[state.step];
  const q=BANK[id];

  elQNo.textContent=`Q${state.step+1}`;

  if(q.kind==="c"){
    elQText.innerHTML=`<div style="margin-bottom:8px">${q.pair.A}</div><div style="opacity:.92">${q.pair.B}</div>`;
    elScale5.style.display="none";
    elScale3.style.display="grid";
    renderScale3();
  }else{
    elQText.textContent=q.text;
    elScale3.style.display="none";
    elScale5.style.display="grid";
    renderScale5();
  }

  state.pending=null;
  btnNext.disabled=true;
  btnBack.disabled=(state.step===0);

  setProgress();
  updateSide();
}

/* =========================================================
   12) 回答・更新
   ========================================================= */
function applyAnswer(){
  const id=state.asked[state.step];
  const q=BANK[id];

  if(!state.pending) return;

  if(q.kind==="c"){
    const key=state.pending.key;
    state.answers[state.step]={id,kind:q.kind,choiceKey:key,skipped:false};
    state.posterior=bayesUpdateChoice(state.posterior,q,key);
    return;
  }

  const raw=state.pending.raw;
  updateRespStatsLikert(raw);

  const cat=state.pending.cat; // 反転済み
  state.answers[state.step]={id,kind:q.kind,raw,cat,skipped:false};
  state.posterior=bayesUpdateGRM(state.posterior,q,cat);
}

function skipAnswer(){
  const id=state.asked[state.step];
  const q=BANK[id];
  state.answers[state.step]={id,kind:q.kind,skipped:true};
}

function recordHistory(){
  const top1=topN(state.posterior,1)[0]?.[0]||"—";
  state.historyTop1.push(top1);
  state.historyGap.push(gapTop2(state.posterior));
}

function recomputeFromStart(){
  state.posterior=Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length]));
  state.respStats={n:0,mean:0,m2:0,neutral:0,extreme:0};
  state.historyTop1=[];
  state.historyGap=[];

  for(let i=0;i<state.step;i++){
    const a=state.answers[i];
    if(!a || a.skipped) continue;
    const q=BANK[a.id];

    if(q.kind==="c"){
      state.posterior=bayesUpdateChoice(state.posterior,q,a.choiceKey);
    }else{
      updateRespStatsLikert(a.raw);
      state.posterior=bayesUpdateGRM(state.posterior,q,a.cat);
    }
    recordHistory();
  }
}

function goNext(skipped=false){
  if(!skipped && !state.pending) return;

  if(skipped) skipAnswer();
  else applyAnswer();

  recordHistory();
  state.step+=1;

  const st=stopStatus();
  if(st.canStop || state.step>=MAX_Q){
    showResult();
    return;
  }
  renderQuestion();
}

function goBack(){
  if(state.step<=0) return;
  state.step-=1;
  recomputeFromStart();
  renderQuestion();
}

/* =========================================================
   13) 結果 + フィードバック
   ========================================================= */
function typeSummary(t){
  const q=QUADRA[t];
  const lead=MODEL[t][0], crea=MODEL[t][1];
  const values=[...QUADRA_VALUES[q]].join("・");
  const oneLine={
    ILE:"",
    SEI:"快適さと空気を整え、自然体の関係を作る。調整と安定。",
    ESE:"雰囲気を温めつつ現実も回す。人を巻き込みながら整える。",
    LII:"概念の整理と整合性が強い。体系化・矛盾修正。",
    EIE:"流れの意味を掴み、感情表現で推進する。熱量と物語。",
    LSI:"規律と境界を保ち、運用で守る。ぶれない秩序。",
    SLE:"主導して切り開く実行力。決断と突破。",
    IEI:"流れと空気を読み、タイミングを作る。洞察と共鳴。",
    SEE:"関係と主導で現実を動かす。交渉・推進。",
    ILI:"流れを読み、実務を選別する。先読み×現実処理。",
    LIE:"目的へ最短で進む設計。成果へ落とす。",
    ESI:"誠実さと境界で関係を整える。筋と責任。",
    LSE:"実務と環境調整で安定推進。堅実に回す。",
    EII:"関係の質と可能性を大事にする。誠実×成長。",
    IEE:"可能性と関係で新展開を作る。接続と発想。",
    SLI:"快適さと実務で無理なく最適化。静かな改善。"
  }[t]||"—";
  return {quadra:q,lead,crea,values,oneLine};
}

/* フィードバックの核：回答→要素ごとの傾向を集計 */
const EL_JA={Te:"Te（実務/効率）",Ti:"Ti（構造/定義）",Fe:"Fe（場/表現）",Fi:"Fi（信頼/距離）",Ne:"Ne（可能性）",Ni:"Ni（流れ/意味）",Se:"Se（主導/圧）",Si:"Si（快適/調整）"};

function expectedSignForType(type, q){
  // + が「その設問で肯定しやすい向き」、- が「否定しやすい向き」
  if(q.kind==="v"){
    const exp=isValued(type,q.element)? +1 : -1;
    return exp * q.dir;
  }
  if(q.kind==="d"){
    // 次元が高いほど肯定寄り、として符号を作る（強さの期待）
    const dim=elementDim(type,q.element);
    const th=(dimToTheta[dim]??0);
    return Math.sign(th||0) * q.dir;
  }
  if(q.kind==="s"){
    // 暗示：5th一致で肯定寄り
    const e=q.element;
    if(isSuggestive(type,e)) return +1 * q.dir;
    if(elementPos(type,e)===0 || elementPos(type,e)===1) return -1 * q.dir;
    return -1 * q.dir;
  }
  if(q.kind==="m"){
    // 動員：6th一致で肯定寄り
    const e=q.element;
    if(isMobilizing(type,e)) return +1 * q.dir;
    if(elementPos(type,e)===0 || elementPos(type,e)===1) return -1 * q.dir;
    return -1 * q.dir;
  }
  return 0;
}

function analyzeAnswersForType(type){
  const agg={}; const w={}; const sm={S:{},M:{}};
  ELEMENTS.forEach(e=>{agg[e]=0;w[e]=0; sm.S[e]=0; sm.M[e]=0;});

  let counted=0;

  for(let i=0;i<state.step;i++){
    const a=state.answers[i];
    if(!a || a.skipped) continue;
    const q=BANK[a.id];

    if(q.kind==="c"){
      // choiceは要素に直接ひも付けづらいので、フィードバックでは「参考」扱い（ここでは集計しない）
      continue;
    }

    if(!q.element) continue;
    const e=q.element;

    // 回答の向き（-2..+2）を、設問dir込みで揃える
    const resp = (a.raw ?? 0); // Likert raw
    const respAligned = resp * q.dir;

    // 期待符号（typeが肯定しやすい向き）と照合して「そのタイプらしさに沿った回答」なら + に寄せる
    const expSign = expectedSignForType(type,q); // -1/0/+1
    const score = (expSign===0) ? 0 : (respAligned * expSign); // 大きいほど「タイプに沿う」

    // 重み：暗示/動員は少し強めに見る（ユーザー要望）
    const weight = (q.kind==="s" || q.kind==="m") ? 1.15 : (q.kind==="d" ? 1.05 : 1.0);

    agg[e] += score * weight;
    w[e] += Math.abs(respAligned) * weight + 0.6; // 回答が強いほど、サンプルが多いほど信頼
    counted++;

    if(q.kind==="s") sm.S[e] += (respAligned); // 素直に肯定(+)が「サポート志向が強い」
    if(q.kind==="m") sm.M[e] += (respAligned); // 素直に肯定(+)が「背伸びしやすい」
  }

  // 正規化（要素ごと）
  const norm={};
  ELEMENTS.forEach(e=>{
    norm[e] = (w[e] > 0) ? (agg[e]/w[e]) : 0; // おおむね -2..+2 の間に収まる
  });

  return {norm, sm, counted};
}

function quadraBlurb(q){
  return {
    Alpha:"α（アルファ）：発想（Ne）と構造（Ti）を軸に、場の快さ（Si）や雰囲気（Fe）を回しやすい傾向。",
    Beta :"β（ベータ）：熱量（Fe）と流れ（Ni）で意味づけし、主導（Se）と構造（Ti）で押し切る傾向。",
    Gamma:"γ（ガンマ）：実利（Te）と関係の筋（Fi）を重視し、主導（Se）と先読み（Ni）で現実を動かす傾向。",
    Delta:"Δ（デルタ）：暮らしの安定（Si）と実務（Te）を基盤に、信頼（Fi）と可能性（Ne）を育てる傾向。"
  }[q] || "—";
}

function showFeedback(topType){
  const q=QUADRA[topType];
  const values=[...QUADRA_VALUES[q]];

  const {norm, sm, counted} = analyzeAnswersForType(topType);

  // 強まり（タイプに沿う要素）
  const strong = Object.entries(norm).sort((a,b)=>b[1]-a[1]).slice(0,3)
    .filter(([_,v])=>v>0.12);

  // ズレ（タイプに反する要素）※「価値要素でズレ」も優先して拾う
  const mismatch = Object.entries(norm).sort((a,b)=>a[1]-b[1]).slice(0,5)
    .filter(([_,v])=>v<-0.12);

  // 価値要素の中でズレが大きいもの
  const valuedMismatch = values
    .map(e=>[e, norm[e] ?? 0])
    .sort((a,b)=>a[1]-b[1])
    .filter(([_,v])=>v<-0.10)
    .slice(0,2);

  // 暗示/動員：1位タイプの5th/6thを提示しつつ、回答が強いところも見せる
  const sugg = MODEL[topType][4];
  const mobi = MODEL[topType][5];

  const smS = Object.entries(sm.S).sort((a,b)=>b[1]-a[1]).slice(0,2);
  const smM = Object.entries(sm.M).sort((a,b)=>b[1]-a[1]).slice(0,2);

  const fbQuadra = document.getElementById("fbQuadra");
  const fbValues = document.getElementById("fbValues");
  const fbStrong = document.getElementById("fbStrong");
  const fbMismatch = document.getElementById("fbMismatch");
  const fbSM = document.getElementById("fbSM");

  fbQuadra.textContent = quadraBlurb(q);

  fbValues.innerHTML =
    `このクアドラは <b>${values.map(e=>EL_JA[e]).join(" / ")}</b> を「意味がある情報」として扱いやすいです。<br>` +
    `（1位：<b>${topType}</b>）`;

  const strongLine = (strong.length===0)
    ? "明確に強まった要素が少ない（=バランス型、または回答が控えめ）可能性があります。"
    : "特に回答が「1位タイプに沿っていた」要素：<br>" +
      strong.map(([e,v])=>`・<b>${EL_JA[e]}</b>（一致度：${v.toFixed(2)}）`).join("<br>");
  fbStrong.innerHTML = strongLine;

  let mismatchHtml="";
  if(mismatch.length===0 && valuedMismatch.length===0){
    mismatchHtml = "大きなズレは目立ちませんでした。";
  }else{
    const parts=[];
    if(valuedMismatch.length){
      parts.push("価値要素の中で、回答が逆方向に出やすかった点：<br>" +
        valuedMismatch.map(([e,v])=>`・<b>${EL_JA[e]}</b>（ズレ：${v.toFixed(2)}）`).join("<br>")
      );
    }
    if(mismatch.length){
      parts.push("全体でズレが大きい要素（※状況要因やサブタイプで起きやすい）：<br>" +
        mismatch.map(([e,v])=>`・<b>${EL_JA[e]}</b>（ズレ：${v.toFixed(2)}）`).join("<br>")
      );
    }
    mismatchHtml = parts.join("<br><br>");
  }
  fbMismatch.innerHTML = mismatchHtml;

}

function showResult(){
  recomputeFromStart();

  screenQuiz.style.display="none";
  screenResult.style.display="block";

  const top3=topN(state.posterior,3).map(([t,p])=>[t,Math.round(p*1000)/10]);
  document.getElementById("resHeadline").textContent =
    top3.map(([t,p],i)=>`${i+1}位 ${t}（${p}%）`).join(" / ");

  const resCards=document.getElementById("resCards");
  resCards.innerHTML="";
  top3.forEach(([t,p],idx)=>{
    const s=typeSummary(t);
    const div=document.createElement("div");
    div.className="qbox";
    div.innerHTML=`
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
        <div>
          <div class="small">${idx+1}位</div>
          <div style="font-size:18px;font-weight:1200;margin-top:4px">${t}
            <span style="font-size:11px;color:var(--muted);border:1px solid var(--line);background:rgba(10,20,40,.04);border-radius:999px;padding:4px 8px;margin-left:8px">
              ${QSYM[s.quadra]} ${s.quadra}
            </span>
          </div>
        </div>
        <div style="font-weight:1200">${p}%</div>
      </div>
      <div class="hr"></div>
      <div class="small">
        主導：<b style="color:var(--ink)">${s.lead}</b> ／ 創造：<b style="color:var(--ink)">${s.crea}</b><br/>
        価値：${s.values}
      </div>
      <div style="margin-top:10px;line-height:1.9">${s.oneLine}</div>
    `;
    resCards.appendChild(div);
  });

  // フィードバック生成（1位タイプ基準）
  const topType = top3[0]?.[0] || topN(state.posterior,1)[0]?.[0] || "ILE";
  showFeedback(topType);

  updateSide();
}

/* =========================================================
   14) 操作
   ========================================================= */
btnNext.addEventListener("click", ()=>goNext(false));
btnSkip.addEventListener("click", ()=>{ state.pending=null; btnNext.disabled=true; goNext(true); });
btnBack.addEventListener("click", goBack);

document.getElementById("btnRestart").addEventListener("click", ()=>location.reload());
document.getElementById("btnRestartTop").addEventListener("click", ()=>location.reload());

/* 上位候補の表示切替（押したら常時表示に変更できる） */
btnToggleLive.addEventListener("click", ()=>{
  state.livePinned = !state.livePinned;
  if(state.livePinned){
    sideCard.classList.remove("hidden");
    btnToggleLive.textContent="上位候補を非表示";
    updateSide();
  }else{
    sideCard.classList.add("hidden");
    btnToggleLive.textContent="上位候補を表示";
  }
});

/* フィードバック開閉 */
const btnToggleFeedback = document.getElementById("btnToggleFeedback");
const feedbackContent = document.getElementById("feedbackContent");
btnToggleFeedback.addEventListener("click", ()=>{
  const open = feedbackContent.classList.contains("hidden");
  if(open){
    feedbackContent.classList.remove("hidden");
    btnToggleFeedback.textContent="閉じる";
  }else{
    feedbackContent.classList.add("hidden");
    btnToggleFeedback.textContent="開く";
  }
});

/* =========================================================
   start
   ========================================================= */
renderQuestion();
</script>
</body>
</html>






